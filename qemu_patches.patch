diff --git a/accel/tcg/cpu-exec-common.c b/accel/tcg/cpu-exec-common.c
index 7e35d7f4b5..1470fdb870 100644
--- a/accel/tcg/cpu-exec-common.c
+++ b/accel/tcg/cpu-exec-common.c
@@ -24,6 +24,12 @@
 #include "qemu/plugin.h"
 #include "internal.h"
 
+#ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
+#include "tcg/tcg.h"
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_LINUX_USER */
+
 bool tcg_allowed;
 
 /* exit the current TB, but without causing any exception to be raised */
@@ -35,6 +41,30 @@ void cpu_loop_exit_noexc(CPUState *cpu)
 
 void cpu_loop_exit(CPUState *cpu)
 {
+#ifdef CANNOLI
+    // TODO CANNOLI REMOVE THIS BLOCK
+    if (cannoli && cannoli->jit_entry && cannoli->jit_drop &&
+            cpu->env_ptr->cannoli_r12 == CANNOLI_POISON) {
+        fprintf(stderr,
+            "[\x1b[31m!\x1b[0m] Cannoli: Cannoli hit a poisoned JIT exit. \
+Droppping buffer and continuing...\n");
+        cannoli->jit_drop();
+        size_t s[3];
+        cannoli->jit_entry(s);
+        cpu->env_ptr->cannoli_r12 = s[0];
+        cpu->env_ptr->cannoli_r13 = s[1];
+        cpu->env_ptr->cannoli_r14 = s[2];
+    }
+
+    /* If we ever exit the CPU loop, perform a JIT exit */
+    if(cannoli && cannoli->jit_exit) {
+        CPUArchState *env = cpu->env_ptr;
+
+        cannoli->jit_exit(
+                env->cannoli_r12, env->cannoli_r13, env->cannoli_r14);
+    }
+#endif
+
     /* Undo the setting in cpu_tb_exec.  */
     cpu->can_do_io = 1;
     /* Undo any setting in generated code.  */
diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index c724e8b6f1..b067fa84ac 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -449,6 +449,11 @@ cpu_tb_exec(CPUState *cpu, TranslationBlock *itb, int *tb_exit)
     TranslationBlock *last_tb;
     const void *tb_ptr = itb->tc.ptr;
 
+#ifdef CANNOLI
+    /* Poison the cannoli state before entering the JIT */
+    env->cannoli_r12 = CANNOLI_POISON;
+#endif
+
     if (qemu_loglevel_mask(CPU_LOG_TB_CPU | CPU_LOG_EXEC)) {
         log_cpu_exec(log_pc(cpu, itb), cpu, itb);
     }
diff --git a/configure b/configure
index 133f4e3235..1336d97b18 100755
--- a/configure
+++ b/configure
@@ -258,6 +258,7 @@ linux_user=""
 bsd_user=""
 plugins="$default_feature"
 ninja=""
+cannoli=""
 python=
 download="enabled"
 bindir="bin"
@@ -805,6 +806,8 @@ for opt do
   ;;
   --disable-cfi) cfi="false"
   ;;
+  --with-cannoli=*) cannoli="$optarg"
+  ;;
   --disable-download) download="disabled"; git_submodules_action=validate;
   ;;
   --enable-download) download="enabled"; git_submodules_action=update;
@@ -946,6 +949,7 @@ Advanced options (experts only):
   --enable-debug           enable common debug build options
   --disable-werror         disable compilation abort on warning
   --cpu=CPU                Build for host CPU [$cpu]
+  --with-cannoli=/path/to/cannoli Build with fast Cannoli tracing support
   --enable-plugins
                            enable plugins via shared library loading
   --disable-containers     don't use containers for cross-building
@@ -1750,6 +1754,11 @@ if [ "$bsd" = "yes" ] ; then
   echo "CONFIG_BSD=y" >> $config_host_mak
 fi
 
+if [ -n "$cannoli" ] ; then
+    echo "CONFIG_CANNOLI=y" >> $config_host_mak
+    CFLAGS="-I$cannoli $CFLAGS"
+fi
+
 if test "$plugins" = "yes" ; then
     echo "CONFIG_PLUGIN=y" >> $config_host_mak
 fi
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 0875971719..33632b6332 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -36,6 +36,26 @@
 #include "tcg/tcg-cond.h"
 #include "tcg/debug-assert.h"
 
+/*
+ * Currently we only support Cannoli in qemu-user mode. In theory it would work
+ * in qemu-system, but it's kinda pointless if you don't have hooks/traces for
+ * context switches, page table changes, etc.
+ */
+#ifdef CONFIG_USER_ONLY
+#ifdef CONFIG_CANNOLI
+#define CANNOLI
+#ifdef CANNOLI
+#include "jitter/ffi/cannoli.h"
+
+/*
+ * Defined in `linux-user/main.c`. Holds global cannoli state and callback
+ * pointers into Rust
+ */
+extern Cannoli *cannoli;
+#endif /* CANNOLI */
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_USER_ONLY */
+
 /* XXX: make safe guess about sizes */
 #define MAX_OP_PER_INSTR 266
 
@@ -44,6 +64,17 @@
 #define CPU_TEMP_BUF_NLONGS 128
 #define TCG_STATIC_FRAME_SIZE  (CPU_TEMP_BUF_NLONGS * sizeof(long))
 
+/* Default target word size to pointer size.  */
+#ifndef TCG_TARGET_REG_BITS
+# if UINTPTR_MAX == UINT32_MAX
+#  define TCG_TARGET_REG_BITS 32
+# elif UINTPTR_MAX == UINT64_MAX
+#  define TCG_TARGET_REG_BITS 64
+# else
+#  error Unknown pointer size for tcg target
+# endif
+#endif
+
 #if TCG_TARGET_REG_BITS == 32
 typedef int32_t tcg_target_long;
 typedef uint32_t tcg_target_ulong;
diff --git a/linux-user/main.c b/linux-user/main.c
index 96be354897..b921fafa8c 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -60,6 +60,13 @@
 #include "semihosting/semihost.h"
 #endif
 
+#ifdef CANNOLI
+/*
+ * Cannoli is dynamically loaded, thus, we gotta pull in dynamic headers!
+ */
+#include <dlfcn.h>
+#endif /* CANNOLI */
+
 #ifndef AT_FLAGS_PRESERVE_ARGV0
 #define AT_FLAGS_PRESERVE_ARGV0_BIT 0
 #define AT_FLAGS_PRESERVE_ARGV0 (1 << AT_FLAGS_PRESERVE_ARGV0_BIT)
@@ -93,6 +100,13 @@ static bool enable_strace;
 static int last_log_mask;
 static const char *last_log_filename;
 
+#ifdef CANNOLI
+/*
+ * Pointer to bindings registered by `query_version` in Cannoli
+ */
+Cannoli *cannoli;
+#endif /* CANNOLI */
+
 /*
  * When running 32-on-64 we should make sure we can fit all of the possible
  * guest address space into a contiguous chunk of virtual host memory.
@@ -281,6 +295,134 @@ static void handle_arg_log_filename(const char *arg)
     last_log_filename = arg;
 }
 
+#ifdef CANNOLI
+/*
+ * Handles the `--cannoli` command line argument, or the `QEMU_CANNOLI`
+ * environment variable. This is where we load up Cannoli. This can only be
+ * called once.
+ */
+static void handle_arg_cannoli(const char *arg)
+{
+    /* Initialize the Cannoli library */
+    void *cannoli_lib = dlopen(arg, RTLD_NOW);
+    if(!cannoli_lib) {
+        fprintf(stderr, "Cannoli: Failed to load library \"%s\"\n", dlerror());
+        exit(EXIT_FAILURE);
+    }
+
+    /* Get the entry point for Cannoli */
+    Cannoli* (*query_version)(const char*, int, size_t, size_t, size_t) =
+        dlsym(cannoli_lib, CANNOLI_ENTRY);
+    if(!query_version) {
+        fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
+            dlerror());
+        exit(EXIT_FAILURE);
+    }
+
+    /* Determine the offset to GPRs and size of GPRs for this architecture in
+     * the `CPUArchState` structure (pointed to in the JIT by RBP)
+     */
+    size_t gpr_offset;
+    size_t gpr_width;
+    size_t num_gprs;
+
+    /* Create an arch state so we can get some offsets and sizes from it */
+    CPUArchState as;
+
+#ifdef TARGET_ALPHA
+    gpr_offset = offsetof(CPUArchState, ir);
+    gpr_width  = sizeof(as.ir[0]);
+    num_gprs   = sizeof(as.ir) / gpr_width;
+#endif /* TARGET_ALPHA */
+
+#ifdef TARGET_AARCH64
+    /* Idk if this is right, they might use the 32-bit regs in 32-bit mode when
+     * running on aarch64? Not sure. I don't think many Linux-user targets will
+     * use mixed modes anyways so we're probably fine
+     */
+    gpr_offset = offsetof(CPUArchState, xregs);
+    gpr_width  = sizeof(as.xregs[0]);
+    num_gprs   = sizeof(as.xregs) / gpr_width;
+#elif defined(TARGET_ARM)
+    gpr_offset = offsetof(CPUArchState, regs);
+    gpr_width  = sizeof(as.regs[0]);
+    num_gprs   = sizeof(as.regs) / gpr_width;
+#endif /* TARGET_AARCH64 */
+
+#ifdef TARGET_AVR
+    gpr_offset = offsetof(CPUArchState, r);
+    gpr_width  = sizeof(as.r[0]);
+    num_gprs   = sizeof(as.r) / gpr_width;
+#endif /* TARGET_AVR */
+
+#ifdef TARGET_HPPA
+    gpr_offset = offsetof(CPUArchState, gr);
+    gpr_width  = sizeof(as.gr[0]);
+    num_gprs   = sizeof(as.gr) / gpr_width;
+#endif /* TARGET_HPPA */
+
+#ifdef TARGET_M68K
+    gpr_offset = offsetof(CPUArchState, dregs);
+    gpr_width  = sizeof(as.dregs[0]);
+    num_gprs   = (sizeof(as.dregs) + sizeof(as.aregs)) / gpr_width;
+#endif /* TARGET_M68K */
+
+#ifdef TARGET_MIPS
+    gpr_offset = offsetof(CPUArchState, active_tc.gpr);
+    gpr_width  = sizeof(as.active_tc.gpr[0]);
+    num_gprs   = sizeof(as.active_tc.gpr) / gpr_width;
+#endif /* TARGET_MIPS */
+
+#ifdef TARGET_TRICORE
+    gpr_offset = offsetof(CPUArchState, gpr_a);
+    gpr_width  = sizeof(as.gpr_a[0]);
+    num_gprs   = (sizeof(as.gpr_a) + sizeof(as.gpr_d)) / gpr_width;
+#endif /* TARGET_TRICORE */
+
+#ifdef TARGET_OPENRISC
+    gpr_offset = offsetof(CPUArchState, shadow_gpr);
+    gpr_width  = sizeof(as.shadow_gpr[0]);
+    num_gprs   = sizeof(as.shadow_gpr) / gpr_width;
+#endif /* TARGET_OPENRISC */
+
+    /* All architectures that just use `CPUArchState->gregs` */
+#if defined(TARGET_SH4) || defined(TARGET_SPARC)
+    gpr_offset = offsetof(CPUArchState, gregs);
+    gpr_width  = sizeof(as.gregs[0]);
+    num_gprs   = sizeof(as.gregs) / gpr_width;
+#endif
+
+    /* All architectures that just use `CPUArchState->regs` */
+#if defined(TARGET_CRIS) || defined(TARGET_I386) || \
+        defined(TARGET_MICROBLAZE) || defined(TARGET_NIOS2) || \
+        defined(TARGET_RX) || defined(TARGET_S390X) || defined(TARGET_XTENSA)
+    gpr_offset = offsetof(CPUArchState, regs);
+    gpr_width  = sizeof(as.regs[0]);
+    num_gprs   = sizeof(as.regs) / gpr_width;
+#endif
+
+    /* All architectures that just use `CPUArchState->gpr` */
+#if defined(TARGET_HEXAGON) || defined(TARGET_LOONGARCH) || \
+        defined(TARGET_PPC) || defined(TARGET_RISCV)
+    gpr_offset = offsetof(CPUArchState, gpr);
+    gpr_width  = sizeof(as.gpr[0]);
+    num_gprs   = sizeof(as.gpr) / gpr_width;
+#endif /* TARGET_HEXAGON */
+
+    /* Query binding information */
+    cannoli = query_version(UNAME_MACHINE, TARGET_BIG_ENDIAN != 0,
+        gpr_offset, gpr_width, num_gprs);
+
+    /* Check version */
+    if(cannoli->version != CANNOLI_VERSION) {
+        fprintf(stderr, "Cannoli: Version mismatch, expected %" PRIx64
+            ", got %" PRIx64 "\n",
+            CANNOLI_VERSION, cannoli->version);
+        exit(EXIT_FAILURE);
+    }
+}
+#endif /* CANNOLI */
+
 static void handle_arg_set_env(const char *arg)
 {
     char *r, *p, *token;
@@ -495,6 +637,10 @@ static const struct qemu_argument arg_table[] = {
      "range[,...]","filter logging based on address range"},
     {"D",          "QEMU_LOG_FILENAME", true, handle_arg_log_filename,
      "logfile",     "write logs to 'logfile' (default stderr)"},
+#ifdef CANNOLI
+    {"cannoli",    "QEMU_CANNOLI" ,    true,  handle_arg_cannoli,
+     "cannoli.so", "Falk's Cannoli fast JIT hooks"},
+#endif
     {"p",          "QEMU_PAGESIZE",    true,  handle_arg_pagesize,
      "pagesize",   "set the host page size to 'pagesize'"},
     {"one-insn-per-tb",
diff --git a/linux-user/mmap.c b/linux-user/mmap.c
index 9aab48d4a3..ad8a881a6c 100644
--- a/linux-user/mmap.c
+++ b/linux-user/mmap.c
@@ -24,6 +24,11 @@
 #include "user-mmap.h"
 #include "target_mman.h"
 
+#ifdef CONFIG_CANNOLI
+/* Pull in TCG header that has cannoli */
+#include "tcg/tcg.h"
+#endif
+
 static pthread_mutex_t mmap_mutex = PTHREAD_MUTEX_INITIALIZER;
 static __thread int mmap_lock_count;
 
@@ -721,6 +726,29 @@ abi_long target_mmap(abi_ulong start, abi_ulong len, int target_prot,
         }
     }
  the_end:
+#ifdef CONFIG_CANNOLI
+    if(cannoli && cannoli->mmap) {
+        /* Report when mmap() occurs successfully */
+
+        /* Resolve the path for this FD if this is a non-anon mapping */
+        char *pth = NULL;
+        if(!(flags & MAP_ANONYMOUS)) {
+            char buf[64];
+            sprintf(buf, "/proc/%d/fd/%d", getpid(), fd);
+            pth = realpath(buf, NULL);
+        }
+
+        cannoli->mmap(start, len, (flags & MAP_ANONYMOUS) != 0,
+            (target_prot & PROT_READ) != 0, (target_prot & PROT_WRITE) != 0,
+            (target_prot & PROT_EXEC) != 0, pth, offset);
+
+        /* Free the path */
+        if(pth) {
+            free(pth);
+        }
+    }
+#endif
+
     trace_target_mmap_complete(start);
     if (qemu_loglevel_mask(CPU_LOG_PAGE)) {
         FILE *f = qemu_log_trylock();
@@ -806,6 +834,13 @@ int target_munmap(abi_ulong start, abi_ulong len)
 {
     trace_target_munmap(start, len);
 
+#ifdef CONFIG_CANNOLI
+    if(cannoli && cannoli->munmap) {
+        /* Report when we try to unmap memory */
+        cannoli->munmap(start, len);
+    }
+#endif
+
     if (start & ~TARGET_PAGE_MASK) {
         return -TARGET_EINVAL;
     }
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 748a98f3e5..cf7d96bba6 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -33,6 +33,12 @@
 #include "host-signal.h"
 #include "user/safe-syscall.h"
 
+#ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
+#include "tcg/tcg.h"
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_LINUX_USER */
+
 static struct target_sigaction sigact_table[TARGET_NSIG];
 
 static void host_signal_handler(int host_signum, siginfo_t *info,
@@ -794,6 +800,13 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
     bool sync_sig = false;
     void *sigmask = host_signal_mask(uc);
 
+#ifdef CANNOLI
+    /* Save the register state in the cannoli C state */
+    env->cannoli_r12 = uc->uc_mcontext.gregs[REG_R12];
+    env->cannoli_r13 = uc->uc_mcontext.gregs[REG_R13];
+    env->cannoli_r14 = uc->uc_mcontext.gregs[REG_R14];
+#endif
+
     /*
      * Non-spoofed SIGSEGV and SIGBUS are synchronous, and need special
      * handling wrt signal blocking and unwinding.
@@ -823,6 +836,10 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
                 /* If this was a write to a TB protected page, restart. */
                 if (is_write &&
                     handle_sigsegv_accerr_write(cpu, sigmask, pc, guest_addr)) {
+#ifdef CANNOLI
+                    /* Re-poison cannoli */
+                    env->cannoli_r12 = CANNOLI_POISON;
+#endif
                     return;
                 }
 
@@ -852,6 +869,10 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
     /* get target signal number */
     guest_sig = host_to_target_signal(host_sig);
     if (guest_sig < 1 || guest_sig > TARGET_NSIG) {
+#ifdef CANNOLI
+        /* Re-poison cannoli */
+        env->cannoli_r12 = CANNOLI_POISON;
+#endif
         return;
     }
     trace_user_host_signal(env, host_sig, guest_sig);
@@ -893,6 +914,11 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
 
     /* interrupt the virtual CPU as soon as possible */
     cpu_exit(thread_cpu);
+
+#ifdef CANNOLI
+    /* Re-poison cannoli */
+    env->cannoli_r12 = CANNOLI_POISON;
+#endif
 }
 
 /* do_sigaltstack() returns target values and errnos. */
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 9353268cc1..a0024001b5 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -13900,5 +13900,21 @@ abi_long do_syscall(CPUArchState *cpu_env, int num, abi_long arg1,
     }
 
     record_syscall_return(cpu, num, ret);
+
+#ifdef CONFIG_CANNOLI
+    if(cannoli && cannoli->syscall) {
+        uint64_t data[8];
+        data[0] = (uint64_t) arg1;
+        data[1] = (uint64_t) arg2;
+        data[2] = (uint64_t) arg3;
+        data[3] = (uint64_t) arg4;
+        data[4] = (uint64_t) arg5;
+        data[5] = (uint64_t) arg6;
+        data[6] = (uint64_t) arg7;
+        data[7] = (uint64_t) arg8;
+        cannoli->syscall(num, (uint64_t) ret, data, 8, (uint64_t) guest_base);
+    }
+#endif
+
     return ret;
 }
diff --git a/target/alpha/cpu.h b/target/alpha/cpu.h
index 13306665af..d2c963677e 100644
--- a/target/alpha/cpu.h
+++ b/target/alpha/cpu.h
@@ -199,6 +199,13 @@ enum {
 #define MMU_PHYS_IDX     2
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint64_t ir[31];
     float64 fir[31];
     uint64_t pc;
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 88e5accda6..335e4276d8 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -231,6 +231,13 @@ typedef struct ARMMMUFaultInfo ARMMMUFaultInfo;
 typedef struct NVICState NVICState;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     /* Regs for current mode.  */
     uint32_t regs[16];
 
diff --git a/target/arm/tcg/op_helper.c b/target/arm/tcg/op_helper.c
index 3baf8004f6..f70bb6780a 100644
--- a/target/arm/tcg/op_helper.c
+++ b/target/arm/tcg/op_helper.c
@@ -25,6 +25,11 @@
 #include "exec/cpu_ldst.h"
 #include "cpregs.h"
 
+#ifdef CANNOLI
+#include "jitter/ffi/cannoli.h"
+extern Cannoli* cannoli;
+#endif
+
 #define SIGNBIT (uint32_t)0x80000000
 #define SIGNBIT64 ((uint64_t)1 << 63)
 
@@ -62,6 +67,17 @@ void raise_exception(CPUARMState *env, uint32_t excp,
     }
 
     assert(!excp_is_internal(excp));
+#ifdef CANNOLI
+    if (cannoli && cannoli->jit_entry && cannoli->jit_drop &&
+            env->cannoli_r12 == CANNOLI_POISON) {
+        cannoli->jit_drop();
+        size_t s[3];
+        cannoli->jit_entry(s);
+        env->cannoli_r12 = s[0];
+        env->cannoli_r13 = s[1];
+        env->cannoli_r14 = s[2];
+    }
+#endif
     cs->exception_index = excp;
     env->exception.syndrome = syndrome;
     env->exception.target_el = target_el;
diff --git a/target/avr/cpu.h b/target/avr/cpu.h
index 7225174668..452a626427 100644
--- a/target/avr/cpu.h
+++ b/target/avr/cpu.h
@@ -109,6 +109,13 @@ typedef enum AVRFeature {
 } AVRFeature;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint32_t pc_w; /* 0x003fffff up to 22 bits */
 
     uint32_t sregC; /* 0x00000001 1 bit */
diff --git a/target/cris/cpu.h b/target/cris/cpu.h
index 8e37c6e50d..1275266176 100644
--- a/target/cris/cpu.h
+++ b/target/cris/cpu.h
@@ -106,6 +106,13 @@ typedef struct {
 } TLBSet;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
 	uint32_t regs[16];
 	/* P0 - P15 are referred to as special registers in the docs.  */
 	uint32_t pregs[16];
diff --git a/target/hexagon/cpu.h b/target/hexagon/cpu.h
index daef5c3f00..ce27756fd0 100644
--- a/target/hexagon/cpu.h
+++ b/target/hexagon/cpu.h
@@ -83,6 +83,13 @@ typedef struct {
 #define VECTOR_TEMPS_MAX            4
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     target_ulong gpr[TOTAL_PER_THREAD_REGS];
     target_ulong pred[NUM_PREGS];
 
diff --git a/target/hppa/cpu.h b/target/hppa/cpu.h
index 75c5c0ccf7..97a68b5443 100644
--- a/target/hppa/cpu.h
+++ b/target/hppa/cpu.h
@@ -168,6 +168,13 @@ typedef struct {
 } hppa_tlb_entry;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     target_ureg iaoq_f;      /* front */
     target_ureg iaoq_b;      /* back, aka next instruction */
 
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index e0771a1043..0a602412c2 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -1587,6 +1587,13 @@ typedef struct HVFX86LazyFlags {
 } HVFX86LazyFlags;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     /* standard registers */
     target_ulong regs[CPU_NB_REGS];
     target_ulong eip;
diff --git a/target/loongarch/cpu.h b/target/loongarch/cpu.h
index fa371ca8ba..b061836abf 100644
--- a/target/loongarch/cpu.h
+++ b/target/loongarch/cpu.h
@@ -273,6 +273,13 @@ struct LoongArchTLB {
 typedef struct LoongArchTLB LoongArchTLB;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint64_t gpr[32];
     uint64_t pc;
 
diff --git a/target/m68k/cpu.h b/target/m68k/cpu.h
index cf70282717..ddf0827ea4 100644
--- a/target/m68k/cpu.h
+++ b/target/m68k/cpu.h
@@ -81,6 +81,13 @@
 typedef CPU_LDoubleU FPReg;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint32_t dregs[8];
     uint32_t aregs[8];
     uint32_t pc;
diff --git a/target/microblaze/cpu.h b/target/microblaze/cpu.h
index f6cab6ce19..ab3e430830 100644
--- a/target/microblaze/cpu.h
+++ b/target/microblaze/cpu.h
@@ -243,6 +243,13 @@ typedef struct CPUArchState CPUMBState;
 #define USE_NON_SECURE_M_AXI_IC_MASK 0x8
 
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint32_t bvalue;   /* TCG temporary, only valid during a TB */
     uint32_t btarget;  /* Full resolved branch destination */
 
diff --git a/target/mips/cpu.h b/target/mips/cpu.h
index f81bd06f5e..cb13781b90 100644
--- a/target/mips/cpu.h
+++ b/target/mips/cpu.h
@@ -528,6 +528,13 @@ struct TCState {
 
 struct MIPSITUState;
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     TCState active_tc;
     CPUMIPSFPUContext active_fpu;
 
@@ -1198,6 +1205,7 @@ typedef struct CPUArchState {
     QEMUTimer *timer; /* Internal timer */
     Clock *count_clock; /* CP0_Count clock */
     target_ulong exception_base; /* ExceptionBase input to the core */
+    uint64_t cp0_count_ns; /* CP0_Count clock period (in nanoseconds) */
 } CPUMIPSState;
 
 /**
diff --git a/target/nios2/cpu.h b/target/nios2/cpu.h
index 477a3161fd..bb0ae82a49 100644
--- a/target/nios2/cpu.h
+++ b/target/nios2/cpu.h
@@ -186,6 +186,13 @@ FIELD(CR_TLBMISC, EE, 24, 1)
 #define EXCP_MPUD     17
 
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
 #ifdef CONFIG_USER_ONLY
     uint32_t regs[NUM_GP_REGS];
 #else
diff --git a/target/openrisc/cpu.h b/target/openrisc/cpu.h
index ce4d605eb7..c0fa6ca9b1 100644
--- a/target/openrisc/cpu.h
+++ b/target/openrisc/cpu.h
@@ -242,6 +242,13 @@ typedef struct CPUOpenRISCTLBContext {
 #endif
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     target_ulong shadow_gpr[16][32]; /* Shadow registers */
 
     target_ulong pc;          /* Program counter */
diff --git a/target/ppc/cpu.h b/target/ppc/cpu.h
index 25fac9577a..e2e25bc251 100644
--- a/target/ppc/cpu.h
+++ b/target/ppc/cpu.h
@@ -1102,6 +1102,13 @@ DEXCR_ASPECT(PHIE, 6)
 #define PPC_CPU_INDIRECT_OPCODES_LEN 0x20
 
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     /* Most commonly used resources during translated code execution first */
     target_ulong gpr[32];  /* general purpose registers */
     target_ulong gprh[32]; /* storage for GPR MSB, used by the SPE extension */
diff --git a/target/riscv/cpu.h b/target/riscv/cpu.h
index 6ea22e0eea..8e4016883e 100644
--- a/target/riscv/cpu.h
+++ b/target/riscv/cpu.h
@@ -123,6 +123,13 @@ typedef struct PMUCTRState {
 } PMUCTRState;
 
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     target_ulong gpr[32];
     target_ulong gprh[32]; /* 64 top bits of the 128-bit registers */
 
diff --git a/target/rx/cpu.h b/target/rx/cpu.h
index 7f03ffcfed..619446a719 100644
--- a/target/rx/cpu.h
+++ b/target/rx/cpu.h
@@ -67,6 +67,13 @@ enum {
 };
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     /* CPU registers */
     uint32_t regs[NUM_REGS];    /* general registers */
     uint32_t psw_o;             /* O bit of status register */
diff --git a/target/s390x/cpu.h b/target/s390x/cpu.h
index eb5b65b7d3..832c3bf953 100644
--- a/target/s390x/cpu.h
+++ b/target/s390x/cpu.h
@@ -54,6 +54,13 @@ typedef struct PSW {
 } PSW;
 
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint64_t regs[16];     /* GP registers */
     /*
      * The floating point registers are part of the vector registers.
@@ -149,7 +156,6 @@ struct CPUArchState {
 
     /* currently processed sigp order */
     uint8_t sigp_order;
-
 };
 
 static inline uint64_t *get_freg(CPUS390XState *cs, int nr)
diff --git a/target/sh4/cpu.h b/target/sh4/cpu.h
index 1399d3840f..63432aed4b 100644
--- a/target/sh4/cpu.h
+++ b/target/sh4/cpu.h
@@ -139,6 +139,13 @@ typedef struct memory_content {
 } memory_content;
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     uint32_t flags;		/* general execution flags */
     uint32_t gregs[24];		/* general registers */
     float32 fregs[32];		/* floating point registers */
diff --git a/target/sparc/cpu.h b/target/sparc/cpu.h
index 98044572f2..4da341a5b8 100644
--- a/target/sparc/cpu.h
+++ b/target/sparc/cpu.h
@@ -440,6 +440,13 @@ typedef union {
 } SparcV9MMU;
 #endif
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     target_ulong gregs[8]; /* general registers */
     target_ulong *regwptr; /* pointer to current register window */
     target_ulong pc;       /* program counter */
diff --git a/target/tricore/cpu.h b/target/tricore/cpu.h
index 3708405be8..1f41402baf 100644
--- a/target/tricore/cpu.h
+++ b/target/tricore/cpu.h
@@ -27,6 +27,13 @@
 #include "tricore-defs.h"
 
 typedef struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     /* GPR Register */
     uint32_t gpr_a[16];
     uint32_t gpr_d[16];
@@ -179,6 +186,10 @@ typedef struct CPUArchState {
 
     /* Internal CPU feature flags.  */
     uint64_t features;
+
+    const tricore_def_t *cpu_model;
+    void *irq[8];
+    struct QEMUTimer *timer; /* Internal timer */
 } CPUTriCoreState;
 
 /**
diff --git a/target/xtensa/cpu.h b/target/xtensa/cpu.h
index 87fe992ba6..87ceab1ae4 100644
--- a/target/xtensa/cpu.h
+++ b/target/xtensa/cpu.h
@@ -509,6 +509,13 @@ enum {
 #endif
 
 struct CPUArchState {
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
+
     const XtensaConfig *config;
     uint32_t regs[16];
     uint32_t pc;
diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index a6b2eae995..077e58b219 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -45,9 +45,15 @@ static const int tcg_target_reg_alloc_order[] = {
 #if TCG_TARGET_REG_BITS == 64
     TCG_REG_RBP,
     TCG_REG_RBX,
+#ifndef CANNOLI
+/*
+ * Prevent the register scheduler from using r12, r13, and r14. This allows us
+ * to have exclusive access to them through the entire JIT execution
+ */
     TCG_REG_R12,
     TCG_REG_R13,
     TCG_REG_R14,
+#endif /* CANNOLI */
     TCG_REG_R15,
     TCG_REG_R10,
     TCG_REG_R11,
@@ -2187,13 +2193,42 @@ static void tcg_out_qemu_ld_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
     }
 }
 
+#ifdef CANNOLI
+/* Add a PC argument so we know what instruction counter is doing the access */
+static void tcg_out_qemu_ld(TCGContext *s, TCGReg datalo, TCGReg datahi,
+                            TCGReg addrlo, TCGReg addrhi,
+                            MemOpIdx oi, TCGType data_type, uint64_t pc)
+#else
 static void tcg_out_qemu_ld(TCGContext *s, TCGReg datalo, TCGReg datahi,
                             TCGReg addrlo, TCGReg addrhi,
                             MemOpIdx oi, TCGType data_type)
+#endif /* CANNOLI */
 {
     TCGLabelQemuLdst *ldst;
     HostAddress h;
 
+#ifdef CANNOLI
+    /*
+     * This is our load hook. We're first saving off the address.
+     *
+     * Save the address into `r14`. The address often is the output of the load
+     * and thus the address gets clobbered by the load itself. Only saved if
+     * Cannoli has registered memory hooks.
+     */
+    if(cannoli && cannoli->lift_memop) {
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         */
+        if(TCG_TARGET_REG_BITS == 32) {
+            fprintf(stderr, "Cannoli: 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
+    }
+#endif /* CANNOLI */
+
     ldst = prepare_host_addr(s, &h, addrlo, addrhi, oi, true);
     tcg_out_qemu_ld_direct(s, datalo, datahi, h, data_type, get_memop(oi));
 
@@ -2203,6 +2238,92 @@ static void tcg_out_qemu_ld(TCGContext *s, TCGReg datalo, TCGReg datahi,
         ldst->datahi_reg = datahi;
         ldst->raddr = tcg_splitwx_to_rx(s->code_ptr);
     }
+
+#ifdef CANNOLI
+    /*
+     * In the second stage of our load hooks, the load has completed. This
+     * means we now have access to the contents of the load. Request the Rust
+     * code to provide us with some shellcode to inject directly into the
+     * stream. We will provide Rust with the register indicies which contain
+     * the address and data values
+     */
+    if(cannoli && cannoli->lift_memop) {
+         /* Should be large enough for any reasonable shellcode */
+         uint8_t shellcode[1024];
+
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         * (yes, this code _is_ duplicated above, but it should compile to no
+         * cost, so we'll use it excessively to make the code less likely to
+         * break or be accidentally removed)
+         */
+        if(TCG_TARGET_REG_BITS == 32) {
+            fprintf(stderr, "Cannoli: 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        MemOp opc = get_memop(oi);
+
+        /* Determine if we have to report a 64 bit memop to Cannoli. */
+        int32_t reported_op =
+            ((opc & MO_SIZE) == MO_128) ? MO_64 : opc & MO_SIZE;
+
+        /* Determine if we have to swap datahi and datalo */
+        if (((opc & MO_SIZE) == MO_128) && (opc & MO_BSWAP)) {
+            TCGReg t = datalo;
+            datalo = datahi;
+            datahi = t;
+        }
+
+        /*
+         * Invoke lifting callback. Note that we use r14 as the address, as
+         * we saved it there above.
+         */
+        size_t shellcode_size = cannoli->lift_memop(
+            pc, 0, datalo, TCG_REG_R14, reported_op, shellcode,
+            sizeof(shellcode));
+
+        /* Make sure the SO library author is not being naughty ;) */
+        if(shellcode_size > sizeof(shellcode)) {
+            fprintf(stderr, "Cannoli: Load shellcode too large\n");
+            exit(EXIT_FAILURE);
+        }
+
+        /* Inject the shellcode into the JIT stream */
+        for(size_t ii = 0; ii < shellcode_size; ii++) {
+            tcg_out8(s, shellcode[ii]);
+        }
+
+        /*
+         * If we're performing a 128 bit load, inject more shellcode for the
+         * second 64 bit load.
+         */
+        if ((opc & MO_SIZE) == MO_128) {
+            /* Add 8 bytes to r14 so we write datahi to the correct address */
+            tcg_out_addi(s, TCG_REG_R14, 8);
+
+            /*
+             * Invoke lifting callback. Note that we use r14 as the address, as
+             * we saved it there above.
+             */
+            size_t shellcode_size = cannoli->lift_memop(
+                pc, 0, datahi, TCG_REG_R14, reported_op, shellcode,
+                sizeof(shellcode));
+
+            /* Make sure the SO library author is not being naughty ;) */
+            if(shellcode_size > sizeof(shellcode)) {
+                fprintf(stderr, "Cannoli: Load shellcode too large\n");
+                exit(EXIT_FAILURE);
+            }
+
+            /* Inject the extra shellcode into the JIT stream */
+            for(size_t ii = 0; ii < shellcode_size; ii++) {
+                tcg_out8(s, shellcode[ii]);
+            }
+        }
+     }
+#endif /* CANNOLI */
 }
 
 static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
@@ -2314,13 +2435,100 @@ static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
     }
 }
 
+#ifdef CANNOLI
+/* Add a PC argument so we know what instruction counter is doing the access */
+static void tcg_out_qemu_st(TCGContext *s, TCGReg datalo, TCGReg datahi,
+                            TCGReg addrlo, TCGReg addrhi,
+                            MemOpIdx oi, TCGType data_type, uint64_t pc)
+#else
 static void tcg_out_qemu_st(TCGContext *s, TCGReg datalo, TCGReg datahi,
                             TCGReg addrlo, TCGReg addrhi,
                             MemOpIdx oi, TCGType data_type)
+#endif /* CANNOLI */
 {
     TCGLabelQemuLdst *ldst;
     HostAddress h;
 
+#ifdef CANNOLI
+    /*
+     * The Cannoli store hook! This is where we log that a write to memory
+     * is about to happen. Unlike load, this is executed _prior_ to the store,
+     * we already know both the data and address information and thus we don't
+     * need to perform the operation to get either of them.
+     *
+     * Just call into Rust and ask for some shellcode!
+     */
+    if(cannoli && cannoli->lift_memop) {
+        /* Should be large enough for any reasonable shellcode */
+        uint8_t shellcode[1024];
+
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         */
+        if(TCG_TARGET_REG_BITS == 32) {
+            fprintf(stderr, "Cannoli: 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        MemOp opc = get_memop(oi);
+
+        /* Determine if we have to report a 64 bit memop to Cannoli. */
+        int32_t reported_op =
+            ((opc & MO_SIZE) == MO_128) ? MO_64 : opc & MO_SIZE;
+
+        /* Create temp registers as to not mess with TCG's functionality */
+        TCGReg tmp_datalo = datalo;
+        TCGReg tmp_datahi = datahi;
+
+        /* Determine if we have to swap datahi and datalo */
+        if (((opc & MO_SIZE) == MO_128) && (opc & MO_BSWAP)) {
+            TCGReg t = tmp_datalo;
+            tmp_datalo = tmp_datahi;
+            tmp_datahi = t;
+        }
+
+        /* Invoke lifting callback */
+        size_t shellcode_size = cannoli->lift_memop(pc,
+            1, tmp_datalo, addrlo, reported_op, shellcode, sizeof(shellcode));
+
+        /* Make sure the SO library author is not being naughty ;) */
+        if(shellcode_size > sizeof(shellcode)) {
+            fprintf(stderr, "Cannoli: Store shellcode too large\n");
+            exit(EXIT_FAILURE);
+        }
+
+        /* Inject the shellcode into the JIT stream */
+        for(size_t ii = 0; ii < shellcode_size; ii++) {
+            tcg_out8(s, shellcode[ii]);
+        }
+
+        /*
+         * If we're performing a 128 bit store, inject more shellcode for the
+         * second 64 bit store.
+         */
+        if ((opc & MO_SIZE) == MO_128) {
+            tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
+            tcg_out_addi(s, TCG_REG_R14, 8);
+
+            /* Invoke lifting callback */
+            size_t shellcode_size = cannoli->lift_memop(pc, 1, tmp_datahi,
+                    TCG_REG_R14, reported_op, shellcode, sizeof(shellcode));
+
+            /* Make sure the SO library author is not being naughty ;) */
+            if(shellcode_size > sizeof(shellcode)) {
+                fprintf(stderr, "Cannoli: Store shellcode too large\n");
+                exit(EXIT_FAILURE);
+            }
+
+            /* Inject the shellcode into the JIT stream */
+            for(size_t ii = 0; ii < shellcode_size; ii++) {
+                tcg_out8(s, shellcode[ii]);
+            }
+        }
+    }
+#endif /* CANNOLI */
+
     ldst = prepare_host_addr(s, &h, addrlo, addrhi, oi, false);
     tcg_out_qemu_st_direct(s, datalo, datahi, h, get_memop(oi));
 
@@ -2368,9 +2576,16 @@ void tb_target_set_jmp_target(const TranslationBlock *tb, int n,
     /* no need to flush icache explicitly */
 }
 
+#ifdef CANNOLI
+static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
+                              const TCGArg args[TCG_MAX_OP_ARGS],
+                              const int const_args[TCG_MAX_OP_ARGS],
+                              const uint64_t pc)
+#else
 static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
                               const TCGArg args[TCG_MAX_OP_ARGS],
                               const int const_args[TCG_MAX_OP_ARGS])
+#endif /* CANNOLI */
 {
     TCGArg a0, a1, a2;
     int c, const_a2, vexop, rexw = 0;
@@ -2616,6 +2831,68 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
         tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_NOT, a0);
         break;
 
+#ifdef CANNOLI
+    /* Cannoli adds a PC argument to loads and stores */
+    case INDEX_op_qemu_ld_a64_i32:
+        if (TCG_TARGET_REG_BITS == 32) {
+            tcg_out_qemu_ld(s, a0, -1, a1, a2, args[3], TCG_TYPE_I32, pc);
+            break;
+        }
+        /* fall through */
+    case INDEX_op_qemu_ld_a32_i32:
+        tcg_out_qemu_ld(s, a0, -1, a1, -1, a2, TCG_TYPE_I32, pc);
+        break;
+    case INDEX_op_qemu_ld_a32_i64:
+        if (TCG_TARGET_REG_BITS == 64) {
+            tcg_out_qemu_ld(s, a0, -1, a1, -1, a2, TCG_TYPE_I64, pc);
+        } else {
+            tcg_out_qemu_ld(s, a0, a1, a2, -1, args[3], TCG_TYPE_I64, pc);
+        }
+        break;
+    case INDEX_op_qemu_ld_a64_i64:
+        if (TCG_TARGET_REG_BITS == 64) {
+            tcg_out_qemu_ld(s, a0, -1, a1, -1, a2, TCG_TYPE_I64, pc);
+        } else {
+            tcg_out_qemu_ld(s, a0, a1, a2, args[3], args[4], TCG_TYPE_I64, pc);
+        }
+        break;
+    case INDEX_op_qemu_ld_a32_i128:
+    case INDEX_op_qemu_ld_a64_i128:
+        tcg_debug_assert(TCG_TARGET_REG_BITS == 64);
+        tcg_out_qemu_ld(s, a0, a1, a2, -1, args[3], TCG_TYPE_I128, pc);
+        break;
+
+    case INDEX_op_qemu_st_a64_i32:
+    case INDEX_op_qemu_st8_a64_i32:
+        if (TCG_TARGET_REG_BITS == 32) {
+            tcg_out_qemu_st(s, a0, -1, a1, a2, args[3], TCG_TYPE_I32, pc);
+            break;
+        }
+        /* fall through */
+    case INDEX_op_qemu_st_a32_i32:
+    case INDEX_op_qemu_st8_a32_i32:
+        tcg_out_qemu_st(s, a0, -1, a1, -1, a2, TCG_TYPE_I32, pc);
+        break;
+    case INDEX_op_qemu_st_a32_i64:
+        if (TCG_TARGET_REG_BITS == 64) {
+            tcg_out_qemu_st(s, a0, -1, a1, -1, a2, TCG_TYPE_I64, pc);
+        } else {
+            tcg_out_qemu_st(s, a0, a1, a2, -1, args[3], TCG_TYPE_I64, pc);
+        }
+        break;
+    case INDEX_op_qemu_st_a64_i64:
+        if (TCG_TARGET_REG_BITS == 64) {
+            tcg_out_qemu_st(s, a0, -1, a1, -1, a2, TCG_TYPE_I64, pc);
+        } else {
+            tcg_out_qemu_st(s, a0, a1, a2, args[3], args[4], TCG_TYPE_I64, pc);
+        }
+        break;
+    case INDEX_op_qemu_st_a32_i128:
+    case INDEX_op_qemu_st_a64_i128:
+        tcg_debug_assert(TCG_TARGET_REG_BITS == 64);
+        tcg_out_qemu_st(s, a0, a1, a2, -1, args[3], TCG_TYPE_I128, pc);
+        break;
+#else
     case INDEX_op_qemu_ld_a64_i32:
         if (TCG_TARGET_REG_BITS == 32) {
             tcg_out_qemu_ld(s, a0, -1, a1, a2, args[3], TCG_TYPE_I32);
@@ -2675,6 +2952,7 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
         tcg_debug_assert(TCG_TARGET_REG_BITS == 64);
         tcg_out_qemu_st(s, a0, a1, a2, -1, args[3], TCG_TYPE_I128);
         break;
+#endif /* CANNOLI */
 
     OP_32_64(mulu2):
         tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_MUL, args[3]);
@@ -4063,6 +4341,80 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, tcg_target_callee_save_regs[i]);
     }
 
+#ifdef CANNOLI
+    /*
+     * So, the location that we're hooking here in QEMU is the code which
+     * is emit as the entry and exit routines for the JIT. We're in the
+     * function that is creating the "trampoline" that jumps into the JIT!
+     * We're hooking first thing after registers are saved and we've
+     * "switched" into the JIT context.
+     *
+     * The reason we hook this location is because it provides us with a
+     * low-frequency event that allows us to flush logs. By low frequency,
+     * I really just mean, happens rare enough that I can call into Rust
+     * and do a slightly more complicated operation. This in reality will
+     * be hit likely thousands of times a second, but that's not too hard
+     * for us.
+     */
+    if(cannoli && cannoli->jit_entry) {
+        /*
+         * Save all of the registers which are caller-saved. In theory we could
+         * be a bit more specific here, but this allows us to not interfere
+         * with any shenanigans that QEMU might do now, or in the future. This
+         * gives us our own environment to run in where we don't have to worry
+         * about specifics
+         *
+         * x86-64 SYS-V ABI:
+         * Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+         * Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+         */
+        tcg_out_push(s, TCG_REG_RAX);
+        tcg_out_push(s, TCG_REG_RDI);
+        tcg_out_push(s, TCG_REG_RSI);
+        tcg_out_push(s, TCG_REG_RDX);
+        tcg_out_push(s, TCG_REG_RCX);
+        tcg_out_push(s, TCG_REG_R8);
+        tcg_out_push(s, TCG_REG_R9);
+        tcg_out_push(s, TCG_REG_R10);
+        tcg_out_push(s, TCG_REG_R11);
+
+        /*
+         * Make some room on the stack for the 3 64-bit return values, but also
+         * align the stack to a 16-byte boundary so it matches the x64 ABI
+         */
+        tcg_out_addi(s, TCG_REG_RSP, -32);
+
+        /*
+         * Load a pointer to the temporary storage for the (u64, u64) into the
+         * first argument to `jit_entry`
+         */
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_RSP);
+
+        /* Invoke the JIT entry callback */
+        tcg_out_call(s, (void*)cannoli->jit_entry, NULL);
+
+        /*
+         * Load the temporary values returned from `jit_entry`. These are the
+         * values for our registers we have full control over in the JIT
+         */
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_REG_RSP, 0x00);
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_REG_RSP, 0x08);
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_REG_RSP, 0x10);
+
+        /* Restore the stack */
+        tcg_out_addi(s, TCG_REG_RSP, 32);
+        tcg_out_pop(s, TCG_REG_R11);
+        tcg_out_pop(s, TCG_REG_R10);
+        tcg_out_pop(s, TCG_REG_R9);
+        tcg_out_pop(s, TCG_REG_R8);
+        tcg_out_pop(s, TCG_REG_RCX);
+        tcg_out_pop(s, TCG_REG_RDX);
+        tcg_out_pop(s, TCG_REG_RSI);
+        tcg_out_pop(s, TCG_REG_RDI);
+        tcg_out_pop(s, TCG_REG_RAX);
+    }
+#endif /* CANNOLI */
+
 #if TCG_TARGET_REG_BITS == 32
     tcg_out_ld(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP,
                (ARRAY_SIZE(tcg_target_callee_save_regs) + 1) * 4);
@@ -4108,6 +4460,59 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     if (have_avx2) {
         tcg_out_vex_opc(s, OPC_VZEROUPPER, 0, 0, 0, 0);
     }
+
+#ifdef CANNOLI
+    /*
+     * Here's the JIT exit hook. This calls into our Rust hooks, and will
+     * always be invoked after a JIT entry (unless there's a crash). This is
+     * where we get Rust execution and send off the trace for processing.
+     */
+    if(cannoli && cannoli->jit_exit) {
+        /*
+         * Save all of the registers which are caller-saved. In theory we could
+         * be a bit more specific here, but this allows us to not interfere
+         * with any shenanigans that QEMU might do now, or in the future. This
+         * gives us our own environment to run in where we don't have to worry
+         * about specifics
+         *
+         * x86-64 SYS-V ABI:
+         * Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+         * Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+         */
+        tcg_out_push(s, TCG_REG_RAX);
+        tcg_out_push(s, TCG_REG_RDI);
+        tcg_out_push(s, TCG_REG_RSI);
+        tcg_out_push(s, TCG_REG_RDX);
+        tcg_out_push(s, TCG_REG_RCX);
+        tcg_out_push(s, TCG_REG_R8);
+        tcg_out_push(s, TCG_REG_R9);
+        tcg_out_push(s, TCG_REG_R10);
+        tcg_out_push(s, TCG_REG_R11);
+
+        /*
+         * Load the 3 controlled registers into the first 3 arguments of the
+         * JIT exit function
+         */
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_R12);
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RSI, TCG_REG_R13);
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDX, TCG_REG_R14);
+
+        /* Invoke the callback! */
+        tcg_out_call(s, (void*)cannoli->jit_exit, NULL);
+
+        /* Restore the stack */
+        tcg_out_pop(s, TCG_REG_R11);
+        tcg_out_pop(s, TCG_REG_R10);
+        tcg_out_pop(s, TCG_REG_R9);
+        tcg_out_pop(s, TCG_REG_R8);
+        tcg_out_pop(s, TCG_REG_RCX);
+        tcg_out_pop(s, TCG_REG_RDX);
+        tcg_out_pop(s, TCG_REG_RSI);
+        tcg_out_pop(s, TCG_REG_RDI);
+        tcg_out_pop(s, TCG_REG_RAX);
+    }
+#endif /* CANNOLI */
+
     for (i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i >= 0; i--) {
         tcg_out_pop(s, tcg_target_callee_save_regs[i]);
     }
diff --git a/tcg/tcg.c b/tcg/tcg.c
index ddfe9a96cb..b1da758b7b 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -126,9 +126,16 @@ static void tcg_out_addi_ptr(TCGContext *s, TCGReg, TCGReg, tcg_target_long);
 static bool tcg_out_xchg(TCGContext *s, TCGType type, TCGReg r1, TCGReg r2);
 static void tcg_out_exit_tb(TCGContext *s, uintptr_t arg);
 static void tcg_out_goto_tb(TCGContext *s, int which);
+#ifdef CANNOLI
+static void tcg_out_op(TCGContext *s, TCGOpcode opc,
+                       const TCGArg args[TCG_MAX_OP_ARGS],
+                       const int const_args[TCG_MAX_OP_ARGS],
+                       const uint64_t pc);
+#else
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg args[TCG_MAX_OP_ARGS],
                        const int const_args[TCG_MAX_OP_ARGS]);
+#endif
 #if TCG_TARGET_MAYBE_vec
 static bool tcg_out_dup_vec(TCGContext *s, TCGType type, unsigned vece,
                             TCGReg dst, TCGReg src);
@@ -4646,7 +4653,15 @@ static void tcg_reg_alloc_dup(TCGContext *s, const TCGOp *op)
     }
 }
 
+/* Cannoli passes the PC of the opcode to the IL op */
+#ifdef CANNOLI
+static void tcg_reg_alloc_op(
+        TCGContext *s,
+        const TCGOp *op,
+        const uint64_t pc)
+#else
 static void tcg_reg_alloc_op(TCGContext *s, const TCGOp *op)
+#endif
 {
     const TCGLifeData arg_life = op->life;
     const TCGOpDef * const def = &tcg_op_defs[op->opc];
@@ -4993,7 +5008,12 @@ static void tcg_reg_alloc_op(TCGContext *s, const TCGOp *op)
             tcg_out_vec_op(s, op->opc, TCGOP_VECL(op), TCGOP_VECE(op),
                            new_args, const_args);
         } else {
+#ifdef CANNOLI
+            /* Cannoli passes the PC */
+            tcg_out_op(s, op->opc, new_args, const_args, pc);
+#else
             tcg_out_op(s, op->opc, new_args, const_args);
+#endif
         }
         break;
     }
@@ -5245,6 +5265,19 @@ static void tcg_reg_alloc_call(TCGContext *s, TCGOp *op)
         }
         load_arg_ref(s, 0, ts->mem_base->reg, ts->mem_offset, &allocated_regs);
     }
+#ifdef CANNOLI
+    /* Save current cannoli registers to an accessible-by-C location as we may
+     * be calling something that longjmp()s from inside QEMU's JIT to outside
+     * and will need to flush the buffers. Thus, from C functions we have to
+     * have access to the current buffer state.
+     */
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_AREG0,
+            sizeof(uint64_t) * CANNOLI_R12_OFFSET);
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_AREG0,
+            sizeof(uint64_t) * CANNOLI_R13_OFFSET);
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_AREG0,
+            sizeof(uint64_t) * CANNOLI_R14_OFFSET);
+#endif
 
     tcg_out_call(s, tcg_call_func(op), info);
 
@@ -5289,6 +5322,18 @@ static void tcg_reg_alloc_call(TCGContext *s, TCGOp *op)
     default:
         g_assert_not_reached();
     }
+#ifdef CANNOLI
+    /* Poison the current C-side cannoli register state as we're about to
+     * track them in registers.
+     *
+     * We re-poison here as we're about to go back into the JIT as the call
+     * above returned back to us instead of longjmp()ing.
+     */
+    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_RDI, CANNOLI_POISON);
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_AREG0,
+            sizeof(uint64_t) * CANNOLI_R12_OFFSET);
+#endif
+
 
     /* Flush or discard output registers as needed. */
     for (i = 0; i < nb_oargs; i++) {
@@ -6009,6 +6054,11 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, uint64_t pc_start)
     s->gen_insn_data =
         tcg_malloc(sizeof(uint64_t) * s->gen_tb->icount * start_words);
 
+#ifdef CANNOLI
+    // Current target program counter. Updated by insn_start instructions
+    uint64_t cannoli_pc = (uint64_t)0xdeaddeaddeaddeadULL;
+#endif // CANNOLI
+
     num_insns = -1;
     QTAILQ_FOREACH(op, &s->ops, link) {
         TCGOpcode opc = op->opc;
@@ -6034,6 +6084,72 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, uint64_t pc_start)
                 s->gen_insn_data[num_insns * start_words + i] =
                     tcg_get_insn_start_param(op, i);
             }
+
+#ifdef CANNOLI
+            /**
+             * In user applications, the instruction argument holds the absolute
+             * pc address
+             */
+            cannoli_pc = s->gen_insn_data[num_insns * start_words];
+
+            /*
+             * First `insn_start` variable is the PC of the instruction.
+             * It may be encoded as 2 32-bit ints when emulating a
+             * larger-than-native architecture than the host of QEMU.
+             *
+             * We let the code above us handle that decoding, thus we just
+             * access the `gen_insn_data` ourselves
+             */
+            if(cannoli && cannoli->lift_instruction) {
+                /* Look ahead at the TCG instructions for this instruction. If
+                 * there is one that is a basic block end, we save that info
+                 * off. Here we're just looking for what could be branches.
+                 * All branches are basic block ends in TCG, some other things
+                 * are also BB ends, but that's okay, we won't have
+                 * false-negatives, only false-positives.
+                 */
+                TCGOp *tmp_op = op->link.tqe_next;
+                int bb_end_in_inst = 0;
+                while(tmp_op) {
+                    if(tmp_op->opc == INDEX_op_insn_start) {
+                        /* Stop processing when we get to the next instruction
+                         * start.
+                         */
+                        break;
+                    }
+
+                    /* Check if this instruction ends a basic block */
+                    TCGOpDef *def = &tcg_op_defs[tmp_op->opc];
+                    if(def->flags & TCG_OPF_BB_END) {
+                        bb_end_in_inst = 1;
+                    }
+
+                    /* Go to the next op */
+                    tmp_op = tmp_op->link.tqe_next;
+                }
+
+                /* Should be large enough for any reasonable shellcode */
+                uint8_t shellcode[1024];
+
+                /* Invoke lifting callback */
+                size_t shellcode_size =
+                    cannoli->lift_instruction(
+                        cannoli_pc, bb_end_in_inst,
+                        shellcode, sizeof(shellcode));
+
+                /* Make sure the SO library author is not being naughty ;) */
+                if(shellcode_size > sizeof(shellcode)) {
+                    fprintf(stderr,
+                            "Cannoli: Instruction shellcode too large\n");
+                    exit(EXIT_FAILURE);
+                }
+
+                /* Inject the shellcode into the JIT stream */
+                for(size_t ii = 0; ii < shellcode_size; ii++) {
+                    tcg_out8(s, shellcode[ii]);
+                }
+            }
+#endif
             break;
         case INDEX_op_discard:
             temp_dead(s, arg_temp(op->args[0]));
@@ -6062,7 +6178,11 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, uint64_t pc_start)
             /* Note: in order to speed up the code, it would be much
                faster to have specialized register allocator functions for
                some common argument patterns */
+#ifdef CANNOLI
+            tcg_reg_alloc_op(s, op, cannoli_pc);
+#else
             tcg_reg_alloc_op(s, op);
+#endif
             break;
         }
         /* Test for (pending) buffer overflow.  The assumption is that any
