From 43cc5f827d47fec9fdc04acd178eb248125c0a83 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Wed, 11 May 2022 07:53:06 -0700
Subject: [PATCH 01/14] Synced with 742848ad987b27fdbeab11323271ca7d196152fb

---
 include/tcg/tcg.h         |  10 +++
 linux-user/main.c         |  46 ++++++++++++
 tcg/i386/tcg-target.c.inc | 145 ++++++++++++++++++++++++++++++++++++++
 tcg/tcg.c                 |  34 +++++++++
 4 files changed, 235 insertions(+)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 6f497172f8..9e91535b66 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -35,6 +35,16 @@
 #include "tcg-target.h"
 #include "tcg/tcg-cond.h"
 
+#ifdef CONFIG_LINUX_USER
+#define CANNOLI
+#ifdef CANNOLI
+#include "/home/pleb/cannoli/qemu_library/ffi/cannoli.h"
+
+// Defined in `linux-user/main.c`
+extern Cannoli *cannoli;
+#endif // CANNOLI
+#endif // CONFIG_LINUX_USER
+
 /* XXX: make safe guess about sizes */
 #define MAX_OP_PER_INSTR 266
 
diff --git a/linux-user/main.c b/linux-user/main.c
index 4290651c3c..bbd8024cd2 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -59,6 +59,10 @@
 #include "semihosting/semihost.h"
 #endif
 
+#ifdef CANNOLI
+#include <dlfcn.h>
+#endif
+
 #ifndef AT_FLAGS_PRESERVE_ARGV0
 #define AT_FLAGS_PRESERVE_ARGV0_BIT 0
 #define AT_FLAGS_PRESERVE_ARGV0 (1 << AT_FLAGS_PRESERVE_ARGV0_BIT)
@@ -91,6 +95,13 @@ static bool enable_strace;
 static int last_log_mask;
 static const char *last_log_filename;
 
+#ifdef CANNOLI
+/*
+ * Pointer to bindings registed by `query_version` in Cannoli
+ */
+Cannoli *cannoli;
+#endif
+
 /*
  * When running 32-on-64 we should make sure we can fit all of the possible
  * guest address space into a contiguous chunk of virtual host memory.
@@ -271,6 +282,37 @@ static void handle_arg_log_filename(const char *arg)
     last_log_filename = arg;
 }
 
+#ifdef CANNOLI
+static void handle_arg_cannoli(const char *arg)
+{
+    // Initialize the Cannoli library
+    void *cannoli_lib = dlopen(arg, RTLD_NOW);
+    if(!cannoli_lib) {
+        fprintf(stderr, "Cannoli: Failed to load library \"%s\"\n", dlerror());
+        exit(EXIT_FAILURE);
+    }
+
+    // Get the entry point for Cannoli
+    Cannoli* (*query_version)(void) = dlsym(cannoli_lib, CANNOLI_ENTRY);
+    if(!query_version) {
+        fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
+            dlerror());
+        exit(EXIT_FAILURE);
+    }
+
+    // Query binding information
+    cannoli = query_version();
+
+    // Check version
+    if(cannoli->version != CANNOLI_VERSION) {
+        fprintf(stderr, "Cannoli: Version mismatch, expected %" PRIx64
+            ", got %" PRIx64 "\n",
+            CANNOLI_VERSION, cannoli->version);
+        exit(EXIT_FAILURE);
+    }
+}
+#endif
+
 static void handle_arg_set_env(const char *arg)
 {
     char *r, *p, *token;
@@ -484,6 +526,10 @@ static const struct qemu_argument arg_table[] = {
      "range[,...]","filter logging based on address range"},
     {"D",          "QEMU_LOG_FILENAME", true, handle_arg_log_filename,
      "logfile",     "write logs to 'logfile' (default stderr)"},
+#ifdef CANNOLI
+    {"cannoli",    "QEMU_CANNOLI" ,    true,  handle_arg_cannoli,
+     "cannoli.so", "Falk's Cannoli fast JIT hooks"},
+#endif
     {"p",          "QEMU_PAGESIZE",    true,  handle_arg_pagesize,
      "pagesize",   "set the host page size to 'pagesize'"},
     {"singlestep", "QEMU_SINGLESTEP",  false, handle_arg_singlestep,
diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index c71c3e664d..1daa4862df 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -45,9 +45,11 @@ static const int tcg_target_reg_alloc_order[] = {
 #if TCG_TARGET_REG_BITS == 64
     TCG_REG_RBP,
     TCG_REG_RBX,
+#ifndef CANNOLI
     TCG_REG_R12,
     TCG_REG_R13,
     TCG_REG_R14,
+#endif
     TCG_REG_R15,
     TCG_REG_R10,
     TCG_REG_R11,
@@ -2246,9 +2248,36 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
         tcg_out_test_alignment(s, true, addrlo, addrhi, a_bits);
     }
 
+#ifdef CANNOLI
+    tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
+#endif // CANNOLI
+
     tcg_out_qemu_ld_direct(s, datalo, datahi, addrlo, x86_guest_base_index,
                            x86_guest_base_offset, x86_guest_base_seg,
                            is64, opc);
+
+#ifdef CANNOLI
+    if(cannoli && cannoli->lift_memop) {
+        // Should be large enough for any reasonable shellcode
+        uint8_t shellcode[1024];
+
+        // Invoke lifting callback
+        size_t shellcode_size = cannoli->lift_memop(
+            0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
+            sizeof(shellcode));
+
+        // Make sure the SO library author is not being naughty ;)
+        if(shellcode_size > sizeof(shellcode)) {
+            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            exit(EXIT_FAILURE);
+        }
+
+        // Inject the shellcode into the JIT stream
+        for(size_t ii = 0; ii < shellcode_size; ii++) {
+            tcg_out8(s, shellcode[ii]);
+        }
+    }
+#endif // CANNOLI
 #endif
 }
 
@@ -2337,6 +2366,28 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
     add_qemu_ldst_label(s, false, is64, oi, datalo, datahi, addrlo, addrhi,
                         s->code_ptr, label_ptr);
 #else
+#ifdef CANNOLI
+    if(cannoli && cannoli->lift_memop) {
+        // Should be large enough for any reasonable shellcode
+        uint8_t shellcode[1024];
+
+        // Invoke lifting callback
+        size_t shellcode_size = cannoli->lift_memop(
+            1, datalo, addrlo, opc & MO_SIZE, shellcode, sizeof(shellcode));
+
+        // Make sure the SO library author is not being naughty ;)
+        if(shellcode_size > sizeof(shellcode)) {
+            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            exit(EXIT_FAILURE);
+        }
+
+        // Inject the shellcode into the JIT stream
+        for(size_t ii = 0; ii < shellcode_size; ii++) {
+            tcg_out8(s, shellcode[ii]);
+        }
+    }
+#endif // CANNOLI
+
     a_bits = get_alignment_bits(opc);
     if (a_bits) {
         tcg_out_test_alignment(s, false, addrlo, addrhi, a_bits);
@@ -4030,6 +4081,57 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, tcg_target_callee_save_regs[i]);
     }
 
+#ifdef CANNOLI
+    if(cannoli && cannoli->jit_entry) {
+        // Save all of the registers which are caller-saved. In theory we could
+        // be a bit more specific here, but this allows us to not interfere
+        // with any shenanigans that QEMU might do now, or in the future. This
+        // gives us our own environment to run in where we don't have to worry
+        // about specifics
+        //
+        // x86-64 SYS-V ABI:
+        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        tcg_out_push(s, TCG_REG_RAX);
+        tcg_out_push(s, TCG_REG_RDI);
+        tcg_out_push(s, TCG_REG_RSI);
+        tcg_out_push(s, TCG_REG_RDX);
+        tcg_out_push(s, TCG_REG_RCX);
+        tcg_out_push(s, TCG_REG_R8);
+        tcg_out_push(s, TCG_REG_R9);
+        tcg_out_push(s, TCG_REG_R10);
+        tcg_out_push(s, TCG_REG_R11);
+
+        // Make some room on the stack for the 3 64-bit return values, but also
+        // align the stack to a 16-byte boundary so it matches the x64 ABI
+        tcg_out_addi(s, TCG_REG_RSP, -32);
+
+        // Load a pointer to the temporary storage for the (u64, u64) into the
+        // first argument to `jit_entry`
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_RSP);
+
+        tcg_out_call(s, (void*)cannoli->jit_entry);
+
+        // Load the temporary values returned from `jit_entry`. These are the
+        // values for our registers we have full control over in the JIT
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_REG_RSP, 0x00);
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_REG_RSP, 0x08);
+        tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_REG_RSP, 0x10);
+
+        // Restore the stack
+        tcg_out_addi(s, TCG_REG_RSP, 32);
+        tcg_out_pop(s, TCG_REG_R11);
+        tcg_out_pop(s, TCG_REG_R10);
+        tcg_out_pop(s, TCG_REG_R9);
+        tcg_out_pop(s, TCG_REG_R8);
+        tcg_out_pop(s, TCG_REG_RCX);
+        tcg_out_pop(s, TCG_REG_RDX);
+        tcg_out_pop(s, TCG_REG_RSI);
+        tcg_out_pop(s, TCG_REG_RDI);
+        tcg_out_pop(s, TCG_REG_RAX);
+    }
+#endif
+
 #if TCG_TARGET_REG_BITS == 32
     tcg_out_ld(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP,
                (ARRAY_SIZE(tcg_target_callee_save_regs) + 1) * 4);
@@ -4075,6 +4177,49 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     if (have_avx2) {
         tcg_out_vex_opc(s, OPC_VZEROUPPER, 0, 0, 0, 0);
     }
+
+#ifdef CANNOLI
+    if(cannoli && cannoli->jit_exit) {
+        // Save all of the registers which are caller-saved. In theory we could
+        // be a bit more specific here, but this allows us to not interfere
+        // with any shenanigans that QEMU might do now, or in the future. This
+        // gives us our own environment to run in where we don't have to worry
+        // about specifics
+        //
+        // x86-64 SYS-V ABI:
+        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        tcg_out_push(s, TCG_REG_RAX);
+        tcg_out_push(s, TCG_REG_RDI);
+        tcg_out_push(s, TCG_REG_RSI);
+        tcg_out_push(s, TCG_REG_RDX);
+        tcg_out_push(s, TCG_REG_RCX);
+        tcg_out_push(s, TCG_REG_R8);
+        tcg_out_push(s, TCG_REG_R9);
+        tcg_out_push(s, TCG_REG_R10);
+        tcg_out_push(s, TCG_REG_R11);
+
+        // Load the 3 controlled registers into the first 3 arguments of the
+        // JIT exit function
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_R12);
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RSI, TCG_REG_R13);
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDX, TCG_REG_R14);
+
+        tcg_out_call(s, (void*)cannoli->jit_exit);
+
+        // Restore the stack
+        tcg_out_pop(s, TCG_REG_R11);
+        tcg_out_pop(s, TCG_REG_R10);
+        tcg_out_pop(s, TCG_REG_R9);
+        tcg_out_pop(s, TCG_REG_R8);
+        tcg_out_pop(s, TCG_REG_RCX);
+        tcg_out_pop(s, TCG_REG_RDX);
+        tcg_out_pop(s, TCG_REG_RSI);
+        tcg_out_pop(s, TCG_REG_RDI);
+        tcg_out_pop(s, TCG_REG_RAX);
+    }
+#endif
+
     for (i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i >= 0; i--) {
         tcg_out_pop(s, tcg_target_callee_save_regs[i]);
     }
diff --git a/tcg/tcg.c b/tcg/tcg.c
index d502327be2..81cf762daf 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4721,6 +4721,40 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
 #endif
                 s->gen_insn_data[num_insns][i] = a;
             }
+
+#ifdef CANNOLI
+            // First `insn_start` variable is the PC of the instruction.
+            // It may be encoded as 2 32-bit ints when emulating a
+            // larger-than-native architecture than the host of QEMU.
+            //
+            // We let the code above us handle that decoding, thus we just
+            // access the `gen_insn_data` ourselves
+            if(cannoli) {
+                if(cannoli->lift_instruction) {
+                    // Should be large enough for any reasonable shellcode
+                    uint8_t shellcode[1024];
+
+                    // Get the PC
+                    target_ulong pc = s->gen_insn_data[num_insns][0];
+
+                    // Invoke lifting callback
+                    size_t shellcode_size =
+                        cannoli->lift_instruction(
+                            pc, shellcode, sizeof(shellcode));
+
+                    // Make sure the SO library author is not being naughty ;)
+                    if(shellcode_size > sizeof(shellcode)) {
+                        fprintf(stderr, "Cannoli: Shellcode too large\n");
+                        exit(EXIT_FAILURE);
+                    }
+
+                    // Inject the shellcode into the JIT stream
+                    for(size_t ii = 0; ii < shellcode_size; ii++) {
+                        tcg_out8(s, shellcode[ii]);
+                    }
+                }
+            }
+#endif
             break;
         case INDEX_op_discard:
             temp_dead(s, arg_temp(op->args[0]));
-- 
2.39.1


From 89db875a3c846918f3c183f712948381ede6307d Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Thu, 12 May 2022 19:18:52 -0700
Subject: [PATCH 02/14] Style cleanup, more comments

---
 include/tcg/tcg.h         |  14 ++-
 linux-user/main.c         |  24 +++--
 tcg/i386/tcg-target.c.inc | 222 +++++++++++++++++++++++++++-----------
 tcg/tcg.c                 |  57 +++++-----
 4 files changed, 217 insertions(+), 100 deletions(-)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 9e91535b66..9d0d14f635 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -35,15 +35,23 @@
 #include "tcg-target.h"
 #include "tcg/tcg-cond.h"
 
+/*
+ * Currently we only support Cannoli in qemu-user mode. In theory it would work
+ * in qemu-system, but it's kinda pointless if you don't have hooks/traces for
+ * context switches, page table changes, etc.
+ */
 #ifdef CONFIG_LINUX_USER
 #define CANNOLI
 #ifdef CANNOLI
 #include "/home/pleb/cannoli/qemu_library/ffi/cannoli.h"
 
-// Defined in `linux-user/main.c`
+/*
+ * Defined in `linux-user/main.c`. Holds global cannoli state and callback
+ * pointers into Rust
+ */
 extern Cannoli *cannoli;
-#endif // CANNOLI
-#endif // CONFIG_LINUX_USER
+#endif /* CANNOLI */
+#endif /* CONFIG_LINUX_USER */
 
 /* XXX: make safe guess about sizes */
 #define MAX_OP_PER_INSTR 266
diff --git a/linux-user/main.c b/linux-user/main.c
index bbd8024cd2..1ebb10cb97 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -60,8 +60,11 @@
 #endif
 
 #ifdef CANNOLI
+/*
+ * Cannoli is dynamically loaded, thus, we gotta pull in dynamic headers!
+ */
 #include <dlfcn.h>
-#endif
+#endif /* CANNOLI */
 
 #ifndef AT_FLAGS_PRESERVE_ARGV0
 #define AT_FLAGS_PRESERVE_ARGV0_BIT 0
@@ -97,10 +100,10 @@ static const char *last_log_filename;
 
 #ifdef CANNOLI
 /*
- * Pointer to bindings registed by `query_version` in Cannoli
+ * Pointer to bindings registered by `query_version` in Cannoli
  */
 Cannoli *cannoli;
-#endif
+#endif /* CANNOLI */
 
 /*
  * When running 32-on-64 we should make sure we can fit all of the possible
@@ -283,16 +286,21 @@ static void handle_arg_log_filename(const char *arg)
 }
 
 #ifdef CANNOLI
+/*
+ * Handles the `--cannoli` command line argument, or the `QEMU_CANNOLI`
+ * environment variable. This is where we load up Cannoli. This can only be
+ * called once.
+ */
 static void handle_arg_cannoli(const char *arg)
 {
-    // Initialize the Cannoli library
+    /* Initialize the Cannoli library */
     void *cannoli_lib = dlopen(arg, RTLD_NOW);
     if(!cannoli_lib) {
         fprintf(stderr, "Cannoli: Failed to load library \"%s\"\n", dlerror());
         exit(EXIT_FAILURE);
     }
 
-    // Get the entry point for Cannoli
+    /* Get the entry point for Cannoli */
     Cannoli* (*query_version)(void) = dlsym(cannoli_lib, CANNOLI_ENTRY);
     if(!query_version) {
         fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
@@ -300,10 +308,10 @@ static void handle_arg_cannoli(const char *arg)
         exit(EXIT_FAILURE);
     }
 
-    // Query binding information
+    /* Query binding information */
     cannoli = query_version();
 
-    // Check version
+    /* Check version */
     if(cannoli->version != CANNOLI_VERSION) {
         fprintf(stderr, "Cannoli: Version mismatch, expected %" PRIx64
             ", got %" PRIx64 "\n",
@@ -311,7 +319,7 @@ static void handle_arg_cannoli(const char *arg)
         exit(EXIT_FAILURE);
     }
 }
-#endif
+#endif /* CANNOLI */
 
 static void handle_arg_set_env(const char *arg)
 {
diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index 1daa4862df..0c7bb914f8 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -46,10 +46,14 @@ static const int tcg_target_reg_alloc_order[] = {
     TCG_REG_RBP,
     TCG_REG_RBX,
 #ifndef CANNOLI
+/*
+ * Prevent the register scheduler from using r12, r13, and r14. This allows us
+ * to have exclusive access to them through the entire JIT execution
+ */
     TCG_REG_R12,
     TCG_REG_R13,
     TCG_REG_R14,
-#endif
+#endif /* CANNOLI */
     TCG_REG_R15,
     TCG_REG_R10,
     TCG_REG_R11,
@@ -2230,6 +2234,30 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
     oi = *args++;
     opc = get_memop(oi);
 
+#ifdef CANNOLI
+    /*
+     * This is our load hook. We're first saving off the address.
+     *
+     * Save the address into `r14`. The address often is the output of the load
+     * and thus the address gets clobbered by the load itself. Only saved if
+     * Cannoli has registered memory hooks.
+     */
+    if(cannoli && cannoli->lift_memop) {
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         */
+        if((TCG_TARGET_REG_BITS == 32 && is64) ||
+                (TARGET_LONG_BITS > TCG_TARGET_REG_BITS)) {
+            fprintf(stderr,
+                "Cannoli: 64-bit load on 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
+    }
+#endif /* CANNOLI */
+
 #if defined(CONFIG_SOFTMMU)
     mem_index = get_mmuidx(oi);
 
@@ -2248,37 +2276,57 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
         tcg_out_test_alignment(s, true, addrlo, addrhi, a_bits);
     }
 
-#ifdef CANNOLI
-    tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_R14, addrlo);
-#endif // CANNOLI
-
     tcg_out_qemu_ld_direct(s, datalo, datahi, addrlo, x86_guest_base_index,
                            x86_guest_base_offset, x86_guest_base_seg,
                            is64, opc);
+#endif
 
 #ifdef CANNOLI
+    /*
+     * In the second stage of our load hooks, the load has completed. This
+     * means we now have access to the contents of the load. Request the Rust
+     * code to provide us with some shellcode to inject directly into the
+     * stream. We will provide Rust with the register indicies which contain
+     * the address and data values
+     */
     if(cannoli && cannoli->lift_memop) {
-        // Should be large enough for any reasonable shellcode
+        /* Should be large enough for any reasonable shellcode */
         uint8_t shellcode[1024];
 
-        // Invoke lifting callback
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         * (yes, this code _is_ duplicated above, but it should compile to no
+         * cost, so we'll use it excessively to make the code less likely to
+         * break or be accidentally removed)
+         */
+        if((TCG_TARGET_REG_BITS == 32 && is64) ||
+                (TARGET_LONG_BITS > TCG_TARGET_REG_BITS)) {
+            fprintf(stderr,
+                "Cannoli: 64-bit load on 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        /*
+         * Invoke lifting callback. Note that we use r14 as the address, as
+         * we saved it there above.
+         */
         size_t shellcode_size = cannoli->lift_memop(
             0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
             sizeof(shellcode));
 
-        // Make sure the SO library author is not being naughty ;)
+        /* Make sure the SO library author is not being naughty ;) */
         if(shellcode_size > sizeof(shellcode)) {
-            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            fprintf(stderr, "Cannoli: Load shellcode too large\n");
             exit(EXIT_FAILURE);
         }
 
-        // Inject the shellcode into the JIT stream
+        /* Inject the shellcode into the JIT stream */
         for(size_t ii = 0; ii < shellcode_size; ii++) {
             tcg_out8(s, shellcode[ii]);
         }
     }
-#endif // CANNOLI
-#endif
+#endif /* CANNOLI */
 }
 
 static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
@@ -2353,41 +2401,60 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
     oi = *args++;
     opc = get_memop(oi);
 
-#if defined(CONFIG_SOFTMMU)
-    mem_index = get_mmuidx(oi);
-
-    tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,
-                     label_ptr, offsetof(CPUTLBEntry, addr_write));
-
-    /* TLB Hit.  */
-    tcg_out_qemu_st_direct(s, datalo, datahi, TCG_REG_L1, -1, 0, 0, opc);
-
-    /* Record the current context of a store into ldst label */
-    add_qemu_ldst_label(s, false, is64, oi, datalo, datahi, addrlo, addrhi,
-                        s->code_ptr, label_ptr);
-#else
 #ifdef CANNOLI
+    /*
+     * The Cannoli store hook! This is where we log that a write to memory
+     * is about to happen. Unlike load, this is executed _prior_ to the store,
+     * we already know both the data and address information and thus we don't
+     * need to perform the operation to get either of them.
+     *
+     * Just call into Rust and ask for some shellcode!
+     */
     if(cannoli && cannoli->lift_memop) {
-        // Should be large enough for any reasonable shellcode
+        /* Should be large enough for any reasonable shellcode */
         uint8_t shellcode[1024];
 
-        // Invoke lifting callback
+        /* We don't support emulating targets larger than the JIT target.
+         * Sorry, but I don't want to support register pairing in all my APIs.
+         * But we can at least detect and notify the user of this!
+         */
+        if((TCG_TARGET_REG_BITS == 32 && is64) ||
+                (TARGET_LONG_BITS > TCG_TARGET_REG_BITS)) {
+            fprintf(stderr,
+                "Cannoli: 64-bit store on 32-bit not supported");
+            exit(EXIT_FAILURE);
+        }
+
+        /* Invoke lifting callback */
         size_t shellcode_size = cannoli->lift_memop(
             1, datalo, addrlo, opc & MO_SIZE, shellcode, sizeof(shellcode));
 
-        // Make sure the SO library author is not being naughty ;)
+        /* Make sure the SO library author is not being naughty ;) */
         if(shellcode_size > sizeof(shellcode)) {
-            fprintf(stderr, "Cannoli: Shellcode too large\n");
+            fprintf(stderr, "Cannoli: Store shellcode too large\n");
             exit(EXIT_FAILURE);
         }
 
-        // Inject the shellcode into the JIT stream
+        /* Inject the shellcode into the JIT stream */
         for(size_t ii = 0; ii < shellcode_size; ii++) {
             tcg_out8(s, shellcode[ii]);
         }
     }
-#endif // CANNOLI
+#endif /* CANNOLI */
+
+#if defined(CONFIG_SOFTMMU)
+    mem_index = get_mmuidx(oi);
 
+    tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,
+                     label_ptr, offsetof(CPUTLBEntry, addr_write));
+
+    /* TLB Hit.  */
+    tcg_out_qemu_st_direct(s, datalo, datahi, TCG_REG_L1, -1, 0, 0, opc);
+
+    /* Record the current context of a store into ldst label */
+    add_qemu_ldst_label(s, false, is64, oi, datalo, datahi, addrlo, addrhi,
+                        s->code_ptr, label_ptr);
+#else
     a_bits = get_alignment_bits(opc);
     if (a_bits) {
         tcg_out_test_alignment(s, false, addrlo, addrhi, a_bits);
@@ -4082,16 +4149,32 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     }
 
 #ifdef CANNOLI
+    /*
+     * So, the location that we're hooking here in QEMU is the code which
+     * is emit as the entry and exit routines for the JIT. We're in the
+     * function that is creating the "trampoline" that jumps into the JIT!
+     * We're hooking first thing after registers are saved and we've
+     * "switched" into the JIT context.
+     *
+     * The reason we hook this location is because it provides us with a
+     * low-frequency event that allows us to flush logs. By low frequency,
+     * I really just mean, happens rare enough that I can call into Rust
+     * and do a slightly more complicated operation. This in reality will
+     * be hit likely thousands of times a second, but that's not too hard
+     * for us.
+     */
     if(cannoli && cannoli->jit_entry) {
-        // Save all of the registers which are caller-saved. In theory we could
-        // be a bit more specific here, but this allows us to not interfere
-        // with any shenanigans that QEMU might do now, or in the future. This
-        // gives us our own environment to run in where we don't have to worry
-        // about specifics
-        //
-        // x86-64 SYS-V ABI:
-        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
-        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        /*
+         * Save all of the registers which are caller-saved. In theory we could
+         * be a bit more specific here, but this allows us to not interfere
+         * with any shenanigans that QEMU might do now, or in the future. This
+         * gives us our own environment to run in where we don't have to worry
+         * about specifics
+         *
+         * x86-64 SYS-V ABI:
+         * Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+         * Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+         */
         tcg_out_push(s, TCG_REG_RAX);
         tcg_out_push(s, TCG_REG_RDI);
         tcg_out_push(s, TCG_REG_RSI);
@@ -4102,23 +4185,30 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, TCG_REG_R10);
         tcg_out_push(s, TCG_REG_R11);
 
-        // Make some room on the stack for the 3 64-bit return values, but also
-        // align the stack to a 16-byte boundary so it matches the x64 ABI
+        /*
+         * Make some room on the stack for the 3 64-bit return values, but also
+         * align the stack to a 16-byte boundary so it matches the x64 ABI
+         */
         tcg_out_addi(s, TCG_REG_RSP, -32);
 
-        // Load a pointer to the temporary storage for the (u64, u64) into the
-        // first argument to `jit_entry`
+        /*
+         * Load a pointer to the temporary storage for the (u64, u64) into the
+         * first argument to `jit_entry`
+         */
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_RSP);
 
+        /* Invoke the JIT entry callback */
         tcg_out_call(s, (void*)cannoli->jit_entry);
 
-        // Load the temporary values returned from `jit_entry`. These are the
-        // values for our registers we have full control over in the JIT
+        /*
+         * Load the temporary values returned from `jit_entry`. These are the
+         * values for our registers we have full control over in the JIT
+         */
         tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_REG_RSP, 0x00);
         tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_REG_RSP, 0x08);
         tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_REG_RSP, 0x10);
 
-        // Restore the stack
+        /* Restore the stack */
         tcg_out_addi(s, TCG_REG_RSP, 32);
         tcg_out_pop(s, TCG_REG_R11);
         tcg_out_pop(s, TCG_REG_R10);
@@ -4130,7 +4220,7 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_pop(s, TCG_REG_RDI);
         tcg_out_pop(s, TCG_REG_RAX);
     }
-#endif
+#endif /* CANNOLI */
 
 #if TCG_TARGET_REG_BITS == 32
     tcg_out_ld(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP,
@@ -4179,16 +4269,23 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     }
 
 #ifdef CANNOLI
+    /*
+     * Here's the JIT exit hook. This calls into our Rust hooks, and will
+     * always be invoked after a JIT entry (unless there's a crash). This is
+     * where we get Rust execution and send off the trace for processing.
+     */
     if(cannoli && cannoli->jit_exit) {
-        // Save all of the registers which are caller-saved. In theory we could
-        // be a bit more specific here, but this allows us to not interfere
-        // with any shenanigans that QEMU might do now, or in the future. This
-        // gives us our own environment to run in where we don't have to worry
-        // about specifics
-        //
-        // x86-64 SYS-V ABI:
-        // Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
-        // Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+        /*
+         * Save all of the registers which are caller-saved. In theory we could
+         * be a bit more specific here, but this allows us to not interfere
+         * with any shenanigans that QEMU might do now, or in the future. This
+         * gives us our own environment to run in where we don't have to worry
+         * about specifics
+         *
+         * x86-64 SYS-V ABI:
+         * Callee-saved: rbp, rbx, r12, r13, r14, r15, rsp
+         * Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11
+         */
         tcg_out_push(s, TCG_REG_RAX);
         tcg_out_push(s, TCG_REG_RDI);
         tcg_out_push(s, TCG_REG_RSI);
@@ -4199,15 +4296,18 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_push(s, TCG_REG_R10);
         tcg_out_push(s, TCG_REG_R11);
 
-        // Load the 3 controlled registers into the first 3 arguments of the
-        // JIT exit function
+        /*
+         * Load the 3 controlled registers into the first 3 arguments of the
+         * JIT exit function
+         */
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_R12);
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RSI, TCG_REG_R13);
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDX, TCG_REG_R14);
 
+        /* Invoke the callback! */
         tcg_out_call(s, (void*)cannoli->jit_exit);
 
-        // Restore the stack
+        /* Restore the stack */
         tcg_out_pop(s, TCG_REG_R11);
         tcg_out_pop(s, TCG_REG_R10);
         tcg_out_pop(s, TCG_REG_R9);
@@ -4218,7 +4318,7 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_pop(s, TCG_REG_RDI);
         tcg_out_pop(s, TCG_REG_RAX);
     }
-#endif
+#endif /* CANNOLI */
 
     for (i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i >= 0; i--) {
         tcg_out_pop(s, tcg_target_callee_save_regs[i]);
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 81cf762daf..09b58b921b 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4723,35 +4723,36 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
             }
 
 #ifdef CANNOLI
-            // First `insn_start` variable is the PC of the instruction.
-            // It may be encoded as 2 32-bit ints when emulating a
-            // larger-than-native architecture than the host of QEMU.
-            //
-            // We let the code above us handle that decoding, thus we just
-            // access the `gen_insn_data` ourselves
-            if(cannoli) {
-                if(cannoli->lift_instruction) {
-                    // Should be large enough for any reasonable shellcode
-                    uint8_t shellcode[1024];
-
-                    // Get the PC
-                    target_ulong pc = s->gen_insn_data[num_insns][0];
-
-                    // Invoke lifting callback
-                    size_t shellcode_size =
-                        cannoli->lift_instruction(
-                            pc, shellcode, sizeof(shellcode));
-
-                    // Make sure the SO library author is not being naughty ;)
-                    if(shellcode_size > sizeof(shellcode)) {
-                        fprintf(stderr, "Cannoli: Shellcode too large\n");
-                        exit(EXIT_FAILURE);
-                    }
+            /*
+             * First `insn_start` variable is the PC of the instruction.
+             * It may be encoded as 2 32-bit ints when emulating a
+             * larger-than-native architecture than the host of QEMU.
+             *
+             * We let the code above us handle that decoding, thus we just
+             * access the `gen_insn_data` ourselves
+             */
+            if(cannoli && cannoli->lift_instruction) {
+                /* Should be large enough for any reasonable shellcode */
+                uint8_t shellcode[1024];
+
+                /* Get the PC */
+                target_ulong pc = s->gen_insn_data[num_insns][0];
+
+                /* Invoke lifting callback */
+                size_t shellcode_size =
+                    cannoli->lift_instruction(
+                        pc, shellcode, sizeof(shellcode));
+
+                /* Make sure the SO library author is not being naughty ;) */
+                if(shellcode_size > sizeof(shellcode)) {
+                    fprintf(stderr,
+                            "Cannoli: Instruction shellcode too large\n");
+                    exit(EXIT_FAILURE);
+                }
 
-                    // Inject the shellcode into the JIT stream
-                    for(size_t ii = 0; ii < shellcode_size; ii++) {
-                        tcg_out8(s, shellcode[ii]);
-                    }
+                /* Inject the shellcode into the JIT stream */
+                for(size_t ii = 0; ii < shellcode_size; ii++) {
+                    tcg_out8(s, shellcode[ii]);
                 }
             }
 #endif
-- 
2.39.1


From f8596a1c88c05ef16fb0b54bb78e9313f36669b1 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sat, 14 May 2022 00:27:52 -0700
Subject: [PATCH 03/14] Added PC support to memops

---
 tcg/i386/tcg-target.c.inc | 47 +++++++++++++++++++++++++++++++++++++--
 tcg/tcg.c                 | 12 ++++++++++
 2 files changed, 57 insertions(+), 2 deletions(-)

diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index 0c7bb914f8..8fd9bc91fa 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -2214,7 +2214,13 @@ static void tcg_out_qemu_ld_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
 /* XXX: qemu_ld and qemu_st could be modified to clobber only EDX and
    EAX. It will be useful once fixed registers globals are less
    common. */
+#ifdef CANNOLI
+/* Add a PC argument so we know what instruction counter is doing the access */
+static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64,
+    target_ulong pc)
+#else
 static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
+#endif /* CANNOLI */
 {
     TCGReg datalo, datahi, addrlo;
     TCGReg addrhi __attribute__((unused));
@@ -2312,7 +2318,7 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
          * we saved it there above.
          */
         size_t shellcode_size = cannoli->lift_memop(
-            0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
+            pc, 0, datalo, TCG_REG_R14, opc & MO_SIZE, shellcode,
             sizeof(shellcode));
 
         /* Make sure the SO library author is not being naughty ;) */
@@ -2381,7 +2387,13 @@ static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
     }
 }
 
+#ifdef CANNOLI
+/* Add a PC argument so we know what instruction counter is doing the access */
+static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64,
+    target_ulong pc)
+#else
 static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
+#endif
 {
     TCGReg datalo, datahi, addrlo;
     TCGReg addrhi __attribute__((unused));
@@ -2426,7 +2438,7 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
         }
 
         /* Invoke lifting callback */
-        size_t shellcode_size = cannoli->lift_memop(
+        size_t shellcode_size = cannoli->lift_memop(pc,
             1, datalo, addrlo, opc & MO_SIZE, shellcode, sizeof(shellcode));
 
         /* Make sure the SO library author is not being naughty ;) */
@@ -2524,7 +2536,21 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
     a2 = args[2];
     const_a2 = const_args[2];
 
+#ifdef CANNOLI
+    // Current program counter. Updated by insn_start instructions
+    target_ulong pc = 0;
+#endif // CANNOLI
+
     switch (opc) {
+#ifdef CANNOLI
+    case INDEX_op_insn_start:
+        // Cannoli enables pushing of `insn_start`s down to this level, so we
+        // actually have to handle it!
+       
+        // Update the current PC tracker
+        pc = *(target_ulong*)const_args;
+        break;
+#endif // CANNOLI
     case INDEX_op_goto_ptr:
         /* jmp to the given host address (could be epilogue) */
         tcg_out_modrm(s, OPC_GRP5, EXT5_JMPN_Ev, a0);
@@ -2762,6 +2788,22 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
         tcg_out_ext16u(s, a0, a1);
         break;
 
+#ifdef CANNOLI
+    /* Cannoli adds a PC argument to loads and stores */
+    case INDEX_op_qemu_ld_i32:
+        tcg_out_qemu_ld(s, args, 0, pc);
+        break;
+    case INDEX_op_qemu_ld_i64:
+        tcg_out_qemu_ld(s, args, 1, pc);
+        break;
+    case INDEX_op_qemu_st_i32:
+    case INDEX_op_qemu_st8_i32:
+        tcg_out_qemu_st(s, args, 0, pc);
+        break;
+    case INDEX_op_qemu_st_i64:
+        tcg_out_qemu_st(s, args, 1, pc);
+        break;
+#else
     case INDEX_op_qemu_ld_i32:
         tcg_out_qemu_ld(s, args, 0);
         break;
@@ -2775,6 +2817,7 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
     case INDEX_op_qemu_st_i64:
         tcg_out_qemu_st(s, args, 1);
         break;
+#endif /* CANNOLI */
 
     OP_32_64(mulu2):
         tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_MUL, args[3]);
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 09b58b921b..5bf36442a0 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4755,6 +4755,18 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
                     tcg_out8(s, shellcode[ii]);
                 }
             }
+            
+            // In Cannoli, we actually emit the `insn_start` opcode. Normally
+            // QEMU does not do this, however we want to get access to PC
+            // values deeper in the stack, so we push the value further.
+            TCGArg args[TCG_MAX_OP_ARGS] = { 0 };
+            int consts[TCG_MAX_OP_ARGS] = { 0 };
+
+            // Write in the PC into the `consts` array
+            *(target_ulong*)consts = s->gen_insn_data[num_insns][0];
+
+            // Emit the opcode
+            tcg_out_op(s, op->opc, args, consts);
 #endif
             break;
         case INDEX_op_discard:
-- 
2.39.1


From 55857c19093b17b2243633d35c32043bf62ec3bb Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sat, 14 May 2022 17:25:18 -0700
Subject: [PATCH 04/14] Updated path

---
 include/tcg/tcg.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 9d0d14f635..34989fb401 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -43,7 +43,7 @@
 #ifdef CONFIG_LINUX_USER
 #define CANNOLI
 #ifdef CANNOLI
-#include "/home/pleb/cannoli/qemu_library/ffi/cannoli.h"
+#include "/home/pleb/cannoli/cannoli_server/ffi/cannoli.h"
 
 /*
  * Defined in `linux-user/main.c`. Holds global cannoli state and callback
-- 
2.39.1


From 6cd2ec65576de5e55507a30c47c7789cd5d42cee Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Thu, 19 May 2022 04:37:37 -0700
Subject: [PATCH 05/14] Added --with-cannoli build flag

---
 configure         | 9 +++++++++
 include/tcg/tcg.h | 4 +++-
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/configure b/configure
index 9e407ce2e3..18ba743e98 100755
--- a/configure
+++ b/configure
@@ -285,6 +285,7 @@ coroutine=""
 plugins="$default_feature"
 meson=""
 ninja=""
+cannoli=""
 bindir="bin"
 skip_meson=no
 vfio_user_server="disabled"
@@ -843,6 +844,8 @@ for opt do
   ;;
   --with-coroutine=*) coroutine="$optarg"
   ;;
+  --with-cannoli=*) cannoli="$optarg"
+  ;;
   --with-git=*) git="$optarg"
   ;;
   --with-git-submodules=*)
@@ -1000,6 +1003,7 @@ Advanced options (experts only):
   --disable-werror         disable compilation abort on warning
   --disable-stack-protector disable compiler-provided stack protection
   --cpu=CPU                Build for host CPU [$cpu]
+  --with-cannoli=/path/to/cannoli Build with fast Cannoli tracing support
   --with-coroutine=BACKEND coroutine backend. Supported options:
                            ucontext, sigaltstack, windows
   --enable-plugins
@@ -2338,6 +2342,11 @@ if [ "$bsd" = "yes" ] ; then
   echo "CONFIG_BSD=y" >> $config_host_mak
 fi
 
+if [ -n "$cannoli" ] ; then
+    echo "CONFIG_CANNOLI=y" >> $config_host_mak
+    QEMU_CFLAGS="-I$cannoli $QEMU_CFLAGS"
+fi
+
 echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
 
 if test "$have_asan_iface_fiber" = "yes" ; then
diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index 34989fb401..addad049af 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -41,9 +41,10 @@
  * context switches, page table changes, etc.
  */
 #ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
 #define CANNOLI
 #ifdef CANNOLI
-#include "/home/pleb/cannoli/cannoli_server/ffi/cannoli.h"
+#include "cannoli_server/ffi/cannoli.h"
 
 /*
  * Defined in `linux-user/main.c`. Holds global cannoli state and callback
@@ -51,6 +52,7 @@
  */
 extern Cannoli *cannoli;
 #endif /* CANNOLI */
+#endif /* CONFIG_CANNOLI */
 #endif /* CONFIG_LINUX_USER */
 
 /* XXX: make safe guess about sizes */
-- 
2.39.1


From a920ea4281aac4cf0e3a121de83e941b11052442 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sun, 29 May 2022 20:56:50 -0700
Subject: [PATCH 06/14] Fixed cannoli PC for memory operations

---
 tcg/i386/tcg-target.c.inc | 21 ++++++-----------
 tcg/tcg.c                 | 47 +++++++++++++++++++++++++--------------
 2 files changed, 37 insertions(+), 31 deletions(-)

diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index 8fd9bc91fa..030f1557e4 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -2513,9 +2513,16 @@ void tb_target_set_jmp_target(const TranslationBlock *tb, int n,
     /* no need to flush icache explicitly */
 }
 
+#ifdef CANNOLI
+static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
+                              const TCGArg args[TCG_MAX_OP_ARGS],
+                              const int const_args[TCG_MAX_OP_ARGS],
+                              const target_ulong pc)
+#else
 static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
                               const TCGArg args[TCG_MAX_OP_ARGS],
                               const int const_args[TCG_MAX_OP_ARGS])
+#endif
 {
     TCGArg a0, a1, a2;
     int c, const_a2, vexop, rexw = 0;
@@ -2536,21 +2543,7 @@ static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,
     a2 = args[2];
     const_a2 = const_args[2];
 
-#ifdef CANNOLI
-    // Current program counter. Updated by insn_start instructions
-    target_ulong pc = 0;
-#endif // CANNOLI
-
     switch (opc) {
-#ifdef CANNOLI
-    case INDEX_op_insn_start:
-        // Cannoli enables pushing of `insn_start`s down to this level, so we
-        // actually have to handle it!
-       
-        // Update the current PC tracker
-        pc = *(target_ulong*)const_args;
-        break;
-#endif // CANNOLI
     case INDEX_op_goto_ptr:
         /* jmp to the given host address (could be epilogue) */
         tcg_out_modrm(s, OPC_GRP5, EXT5_JMPN_Ev, a0);
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 5bf36442a0..812befd1af 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -106,9 +106,16 @@ static void tcg_out_movi(TCGContext *s, TCGType type,
                          TCGReg ret, tcg_target_long arg);
 static void tcg_out_exit_tb(TCGContext *s, uintptr_t arg);
 static void tcg_out_goto_tb(TCGContext *s, int which);
+#ifdef CANNOLI
+static void tcg_out_op(TCGContext *s, TCGOpcode opc,
+                       const TCGArg args[TCG_MAX_OP_ARGS],
+                       const int const_args[TCG_MAX_OP_ARGS],
+                       const target_ulong pc);
+#else
 static void tcg_out_op(TCGContext *s, TCGOpcode opc,
                        const TCGArg args[TCG_MAX_OP_ARGS],
                        const int const_args[TCG_MAX_OP_ARGS]);
+#endif
 #if TCG_TARGET_MAYBE_vec
 static bool tcg_out_dup_vec(TCGContext *s, TCGType type, unsigned vece,
                             TCGReg dst, TCGReg src);
@@ -3892,7 +3899,15 @@ static void tcg_reg_alloc_dup(TCGContext *s, const TCGOp *op)
     }
 }
 
+/* Cannoli passes the PC of the opcode to the IL op */
+#ifdef CANNOLI
+static void tcg_reg_alloc_op(
+        TCGContext *s,
+        const TCGOp *op,
+        const target_ulong pc)
+#else
 static void tcg_reg_alloc_op(TCGContext *s, const TCGOp *op)
+#endif
 {
     const TCGLifeData arg_life = op->life;
     const TCGOpDef * const def = &tcg_op_defs[op->opc];
@@ -4201,7 +4216,12 @@ static void tcg_reg_alloc_op(TCGContext *s, const TCGOp *op)
         tcg_out_vec_op(s, op->opc, TCGOP_VECL(op), TCGOP_VECE(op),
                        new_args, const_args);
     } else {
+#ifdef CANNOLI
+        /* Cannoli passes the PC */
+        tcg_out_op(s, op->opc, new_args, const_args, pc);
+#else
         tcg_out_op(s, op->opc, new_args, const_args);
+#endif
     }
 
     /* move the outputs in the correct register if needed */
@@ -4687,6 +4707,11 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
     s->pool_labels = NULL;
 #endif
 
+#ifdef CANNOLI
+    // Current target program counter. Updated by insn_start instructions
+    target_ulong cannoli_pc = (target_ulong)0xdeaddeaddeaddeadULL;
+#endif // CANNOLI
+
     num_insns = -1;
     QTAILQ_FOREACH(op, &s->ops, link) {
         TCGOpcode opc = op->opc;
@@ -4723,6 +4748,9 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
             }
 
 #ifdef CANNOLI
+            /* Record the PC of the target instruction */
+            cannoli_pc = s->gen_insn_data[num_insns][0];
+
             /*
              * First `insn_start` variable is the PC of the instruction.
              * It may be encoded as 2 32-bit ints when emulating a
@@ -4735,13 +4763,10 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
                 /* Should be large enough for any reasonable shellcode */
                 uint8_t shellcode[1024];
 
-                /* Get the PC */
-                target_ulong pc = s->gen_insn_data[num_insns][0];
-
                 /* Invoke lifting callback */
                 size_t shellcode_size =
                     cannoli->lift_instruction(
-                        pc, shellcode, sizeof(shellcode));
+                        cannoli_pc, shellcode, sizeof(shellcode));
 
                 /* Make sure the SO library author is not being naughty ;) */
                 if(shellcode_size > sizeof(shellcode)) {
@@ -4755,18 +4780,6 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
                     tcg_out8(s, shellcode[ii]);
                 }
             }
-            
-            // In Cannoli, we actually emit the `insn_start` opcode. Normally
-            // QEMU does not do this, however we want to get access to PC
-            // values deeper in the stack, so we push the value further.
-            TCGArg args[TCG_MAX_OP_ARGS] = { 0 };
-            int consts[TCG_MAX_OP_ARGS] = { 0 };
-
-            // Write in the PC into the `consts` array
-            *(target_ulong*)consts = s->gen_insn_data[num_insns][0];
-
-            // Emit the opcode
-            tcg_out_op(s, op->opc, args, consts);
 #endif
             break;
         case INDEX_op_discard:
@@ -4796,7 +4809,7 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
             /* Note: in order to speed up the code, it would be much
                faster to have specialized register allocator functions for
                some common argument patterns */
-            tcg_reg_alloc_op(s, op);
+            tcg_reg_alloc_op(s, op, cannoli_pc);
             break;
         }
         /* Test for (pending) buffer overflow.  The assumption is that any
-- 
2.39.1


From 128fb29e9b13d67767bc8183de0c8f08995dc691 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Mon, 30 May 2022 00:30:14 -0700
Subject: [PATCH 07/14] Wrap code in cannoli as needed

---
 tcg/tcg.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/tcg/tcg.c b/tcg/tcg.c
index 812befd1af..c02f6e602d 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4809,7 +4809,11 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
             /* Note: in order to speed up the code, it would be much
                faster to have specialized register allocator functions for
                some common argument patterns */
+#ifdef CANNOLI
             tcg_reg_alloc_op(s, op, cannoli_pc);
+#else
+            tcg_reg_alloc_op(s, op);
+#endif
             break;
         }
         /* Test for (pending) buffer overflow.  The assumption is that any
-- 
2.39.1


From 72dd745e4d3642bb2df40b50d1a09376c20bbffe Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Mon, 30 May 2022 06:05:07 -0700
Subject: [PATCH 08/14] Fixed cannoli not flushing on longjmps and signals

---
 accel/tcg/cpu-exec-common.c | 16 ++++++++++++++++
 accel/tcg/cpu-exec.c        |  5 +++++
 linux-user/signal.c         | 26 ++++++++++++++++++++++++++
 target/alpha/cpu.h          |  7 +++++++
 target/arm/cpu.h            |  7 +++++++
 target/avr/cpu.h            |  7 +++++++
 target/cris/cpu.h           |  7 +++++++
 target/hexagon/cpu.h        |  7 +++++++
 target/hppa/cpu.h           |  7 +++++++
 target/i386/cpu.h           |  7 +++++++
 target/m68k/cpu.h           |  7 +++++++
 target/microblaze/cpu.h     |  7 +++++++
 target/mips/cpu.h           |  7 +++++++
 target/nios2/cpu.h          |  7 +++++++
 target/openrisc/cpu.h       |  7 +++++++
 target/ppc/cpu.h            |  7 +++++++
 target/riscv/cpu.h          |  7 +++++++
 target/rx/cpu.h             |  7 +++++++
 target/s390x/cpu.h          |  6 ++++++
 target/sh4/cpu.h            |  7 +++++++
 target/sparc/cpu.h          |  7 +++++++
 target/tricore/cpu.h        |  7 +++++++
 target/xtensa/cpu.h         |  7 +++++++
 tcg/tcg.c                   | 26 ++++++++++++++++++++++++++
 24 files changed, 212 insertions(+)

diff --git a/accel/tcg/cpu-exec-common.c b/accel/tcg/cpu-exec-common.c
index c7bc8c6efa..c8ad7fa5ec 100644
--- a/accel/tcg/cpu-exec-common.c
+++ b/accel/tcg/cpu-exec-common.c
@@ -22,6 +22,12 @@
 #include "sysemu/tcg.h"
 #include "exec/exec-all.h"
 
+#ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
+#include "tcg/tcg.h"
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_LINUX_USER */
+
 bool tcg_allowed;
 
 /* exit the current TB, but without causing any exception to be raised */
@@ -63,6 +69,16 @@ void cpu_reloading_memory_map(void)
 
 void cpu_loop_exit(CPUState *cpu)
 {
+#ifdef CANNOLI
+    /* If we ever exit the CPU loop, perform a JIT exit */
+    if(cannoli && cannoli->jit_exit) {
+        CPUArchState *env = cpu->env_ptr;
+
+        cannoli->jit_exit(
+                env->cannoli_r12, env->cannoli_r13, env->cannoli_r14);
+    }
+#endif
+
     /* Undo the setting in cpu_tb_exec.  */
     cpu->can_do_io = 1;
     siglongjmp(cpu->jmp_env, 1);
diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 04cd1f3092..ed293304fe 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -430,6 +430,11 @@ cpu_tb_exec(CPUState *cpu, TranslationBlock *itb, int *tb_exit)
     TranslationBlock *last_tb;
     const void *tb_ptr = itb->tc.ptr;
 
+#ifdef CANNOLI
+    /* Poison the cannoli state before entering the JIT */
+    env->cannoli_r12 = CANNOLI_POISON;
+#endif
+
     if (qemu_loglevel_mask(CPU_LOG_TB_CPU | CPU_LOG_EXEC)) {
         log_cpu_exec(log_pc(cpu, itb), cpu, itb);
     }
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 098f3a787d..516da80460 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -33,6 +33,12 @@
 #include "host-signal.h"
 #include "user/safe-syscall.h"
 
+#ifdef CONFIG_LINUX_USER
+#ifdef CONFIG_CANNOLI
+#include "tcg/tcg.h"
+#endif /* CONFIG_CANNOLI */
+#endif /* CONFIG_LINUX_USER */
+
 static struct target_sigaction sigact_table[TARGET_NSIG];
 
 static void host_signal_handler(int host_signum, siginfo_t *info,
@@ -794,6 +800,13 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
     bool sync_sig = false;
     void *sigmask = host_signal_mask(uc);
 
+#ifdef CANNOLI
+    /* Save the register state in the cannoli C state */
+    env->cannoli_r12 = uc->uc_mcontext.gregs[REG_R12];
+    env->cannoli_r13 = uc->uc_mcontext.gregs[REG_R13];
+    env->cannoli_r14 = uc->uc_mcontext.gregs[REG_R14];
+#endif
+
     /*
      * Non-spoofed SIGSEGV and SIGBUS are synchronous, and need special
      * handling wrt signal blocking and unwinding.
@@ -823,6 +836,10 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
                 /* If this was a write to a TB protected page, restart. */
                 if (is_write &&
                     handle_sigsegv_accerr_write(cpu, sigmask, pc, guest_addr)) {
+#ifdef CANNOLI
+                    /* Re-poison cannoli */
+                    env->cannoli_r12 = CANNOLI_POISON;
+#endif
                     return;
                 }
 
@@ -852,6 +869,10 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
     /* get target signal number */
     guest_sig = host_to_target_signal(host_sig);
     if (guest_sig < 1 || guest_sig > TARGET_NSIG) {
+#ifdef CANNOLI
+        /* Re-poison cannoli */
+        env->cannoli_r12 = CANNOLI_POISON;
+#endif
         return;
     }
     trace_user_host_signal(env, host_sig, guest_sig);
@@ -893,6 +914,11 @@ static void host_signal_handler(int host_sig, siginfo_t *info, void *puc)
 
     /* interrupt the virtual CPU as soon as possible */
     cpu_exit(thread_cpu);
+
+#ifdef CANNOLI
+    /* Re-poison cannoli */
+    env->cannoli_r12 = CANNOLI_POISON;
+#endif
 }
 
 /* do_sigaltstack() returns target values and errnos. */
diff --git a/target/alpha/cpu.h b/target/alpha/cpu.h
index d0abc949a8..f54fb0f15f 100644
--- a/target/alpha/cpu.h
+++ b/target/alpha/cpu.h
@@ -250,6 +250,13 @@ typedef struct CPUArchState {
     uint32_t features;
     uint32_t amask;
     int implver;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUAlphaState;
 
 /**
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 8cf70693be..d58d16346c 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -771,6 +771,13 @@ typedef struct CPUArchState {
     /* Linux syscall tagged address support */
     bool tagged_addr_enable;
 #endif
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUARMState;
 
 static inline void set_feature(CPUARMState *env, int feature)
diff --git a/target/avr/cpu.h b/target/avr/cpu.h
index f19dd72926..3e5744bfcd 100644
--- a/target/avr/cpu.h
+++ b/target/avr/cpu.h
@@ -135,6 +135,13 @@ typedef struct CPUArchState {
     bool fullacc; /* CPU/MEM if true MEM only otherwise */
 
     uint64_t features;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUAVRState;
 
 /**
diff --git a/target/cris/cpu.h b/target/cris/cpu.h
index e6776f25b1..d3dbd56701 100644
--- a/target/cris/cpu.h
+++ b/target/cris/cpu.h
@@ -165,6 +165,13 @@ typedef struct CPUArchState {
 
         /* Members from load_info on are preserved across resets.  */
         void *load_info;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUCRISState;
 
 /**
diff --git a/target/hexagon/cpu.h b/target/hexagon/cpu.h
index 34c0ae0a67..dfcd2c6603 100644
--- a/target/hexagon/cpu.h
+++ b/target/hexagon/cpu.h
@@ -128,6 +128,13 @@ typedef struct CPUArchState {
     target_ulong vstore_pending[VSTORES_MAX];
     bool vtcm_pending;
     VTCMStoreLog vtcm_log;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUHexagonState;
 
 OBJECT_DECLARE_CPU_TYPE(HexagonCPU, HexagonCPUClass, HEXAGON_CPU)
diff --git a/target/hppa/cpu.h b/target/hppa/cpu.h
index 6f3b6beecf..3d8a6e599c 100644
--- a/target/hppa/cpu.h
+++ b/target/hppa/cpu.h
@@ -206,6 +206,13 @@ typedef struct CPUArchState {
     /* ??? We should use a more intelligent data structure.  */
     hppa_tlb_entry tlb[HPPA_TLB_ENTRIES];
     uint32_t tlb_last;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUHPPAState;
 
 /**
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index d4bc19577a..abbd75ec20 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -1811,6 +1811,13 @@ typedef struct CPUArchState {
     TPRAccess tpr_access_type;
 
     unsigned nr_dies;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUX86State;
 
 struct kvm_msrs;
diff --git a/target/m68k/cpu.h b/target/m68k/cpu.h
index 3a9cfe2f33..50d5d39ae4 100644
--- a/target/m68k/cpu.h
+++ b/target/m68k/cpu.h
@@ -155,6 +155,13 @@ typedef struct CPUArchState {
 
     /* Fields from here on are preserved across CPU reset. */
     uint64_t features;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUM68KState;
 
 /*
diff --git a/target/microblaze/cpu.h b/target/microblaze/cpu.h
index 1e84dd8f47..ea21031cb2 100644
--- a/target/microblaze/cpu.h
+++ b/target/microblaze/cpu.h
@@ -291,6 +291,13 @@ struct CPUArchState {
     struct {} end_reset_fields;
 
     /* These fields are preserved on reset.  */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 /*
diff --git a/target/mips/cpu.h b/target/mips/cpu.h
index caf2b06911..1671b5e62b 100644
--- a/target/mips/cpu.h
+++ b/target/mips/cpu.h
@@ -1161,6 +1161,13 @@ typedef struct CPUArchState {
     QEMUTimer *timer; /* Internal timer */
     target_ulong exception_base; /* ExceptionBase input to the core */
     uint64_t cp0_count_ns; /* CP0_Count clock period (in nanoseconds) */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUMIPSState;
 
 /**
diff --git a/target/nios2/cpu.h b/target/nios2/cpu.h
index b1a5549074..e3a72be77e 100644
--- a/target/nios2/cpu.h
+++ b/target/nios2/cpu.h
@@ -200,6 +200,13 @@ struct CPUArchState {
     Nios2MMU mmu;
 #endif
     int error_code;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 typedef struct {
diff --git a/target/openrisc/cpu.h b/target/openrisc/cpu.h
index 5f60749705..a63f25baac 100644
--- a/target/openrisc/cpu.h
+++ b/target/openrisc/cpu.h
@@ -292,6 +292,13 @@ typedef struct CPUArchState {
     uint32_t picmr;         /* Interrupt mask register */
     uint32_t picsr;         /* Interrupt contrl register*/
 #endif
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUOpenRISCState;
 
 /**
diff --git a/target/ppc/cpu.h b/target/ppc/cpu.h
index 3923f174f8..0eae080ac3 100644
--- a/target/ppc/cpu.h
+++ b/target/ppc/cpu.h
@@ -1265,6 +1265,13 @@ struct CPUArchState {
      * running cycles.
      */
     uint64_t pmu_base_time;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 #define SET_FIT_PERIOD(a_, b_, c_, d_)          \
diff --git a/target/riscv/cpu.h b/target/riscv/cpu.h
index bcf0826753..a2825d3251 100644
--- a/target/riscv/cpu.h
+++ b/target/riscv/cpu.h
@@ -394,6 +394,13 @@ struct CPUArchState {
     uint64_t kvm_timer_compare;
     uint64_t kvm_timer_state;
     uint64_t kvm_timer_frequency;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 OBJECT_DECLARE_CPU_TYPE(RISCVCPU, RISCVCPUClass, RISCV_CPU)
diff --git a/target/rx/cpu.h b/target/rx/cpu.h
index 5655dffeff..372bf94bc5 100644
--- a/target/rx/cpu.h
+++ b/target/rx/cpu.h
@@ -98,6 +98,13 @@ typedef struct CPUArchState {
     uint32_t ack_ipl;           /* execute ipl */
     float_status fp_status;
     qemu_irq ack;               /* Interrupt acknowledge */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPURXState;
 
 /*
diff --git a/target/s390x/cpu.h b/target/s390x/cpu.h
index 7d6d01325b..512c69bd03 100644
--- a/target/s390x/cpu.h
+++ b/target/s390x/cpu.h
@@ -151,6 +151,12 @@ struct CPUArchState {
     /* currently processed sigp order */
     uint8_t sigp_order;
 
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 static inline uint64_t *get_freg(CPUS390XState *cs, int nr)
diff --git a/target/sh4/cpu.h b/target/sh4/cpu.h
index 727b829598..1e3d0aad89 100644
--- a/target/sh4/cpu.h
+++ b/target/sh4/cpu.h
@@ -195,6 +195,13 @@ typedef struct CPUArchState {
     int in_sleep;		/* SR_BL ignored during sleep */
     memory_content *movcal_backup;
     memory_content **movcal_backup_tail;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUSH4State;
 
 /**
diff --git a/target/sparc/cpu.h b/target/sparc/cpu.h
index e478c5eb16..6a59a73b53 100644
--- a/target/sparc/cpu.h
+++ b/target/sparc/cpu.h
@@ -549,6 +549,13 @@ struct CPUArchState {
 
     /* Leon3 cache control */
     uint32_t cache_control;
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 /**
diff --git a/target/tricore/cpu.h b/target/tricore/cpu.h
index 3b9c533a7c..28035d9763 100644
--- a/target/tricore/cpu.h
+++ b/target/tricore/cpu.h
@@ -189,6 +189,13 @@ typedef struct CPUArchState {
     const tricore_def_t *cpu_model;
     void *irq[8];
     struct QEMUTimer *timer; /* Internal timer */
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPUTriCoreState;
 
 /**
diff --git a/target/xtensa/cpu.h b/target/xtensa/cpu.h
index 579adcb769..da4af8d732 100644
--- a/target/xtensa/cpu.h
+++ b/target/xtensa/cpu.h
@@ -547,6 +547,13 @@ struct CPUArchState {
 
     /* Watchpoints for DBREAK registers */
     struct CPUWatchpoint *cpu_watchpoint[MAX_NDBREAK];
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 };
 
 /**
diff --git a/tcg/tcg.c b/tcg/tcg.c
index c02f6e602d..9e8b22beb6 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4433,6 +4433,20 @@ static void tcg_reg_alloc_call(TCGContext *s, TCGOp *op)
         save_globals(s, allocated_regs);
     }
 
+#ifdef CANNOLI
+    /* Save current cannoli registers to an accessible-by-C location as we may
+     * be calling something that longjmp()s from inside QEMU's JIT to outside
+     * and will need to flush the buffers. Thus, from C functions we have to
+     * have access to the current buffer state.
+     */
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R12, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r12));
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R13, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r13));
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_R14, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r14));
+#endif
+
     tcg_out_call(s, tcg_call_func(op), info);
 
     /* Assign output registers and emit moves if needed.  */
@@ -4452,6 +4466,18 @@ static void tcg_reg_alloc_call(TCGContext *s, TCGOp *op)
     default:
         g_assert_not_reached();
     }
+#ifdef CANNOLI
+    /* Poison the current C-side cannoli register state as we're about to
+     * track them in registers.
+     *
+     * We re-poison here as we're about to go back into the JIT as the call
+     * above returned back to us instead of longjmp()ing.
+     */
+    tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_RDI, CANNOLI_POISON);
+    tcg_out_st(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_AREG0,
+            offsetof(CPUArchState, cannoli_r12));
+#endif
+
 
     /* Flush or discard output registers as needed. */
     for (i = 0; i < nb_oargs; i++) {
-- 
2.39.1


From bf051f2ed4c1449b6d3e6e71bd00195eac3157e2 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Tue, 31 May 2022 03:03:13 -0700
Subject: [PATCH 09/14] Pass endian and arch information to cannoli

---
 linux-user/main.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/linux-user/main.c b/linux-user/main.c
index 1ebb10cb97..060a09b3f8 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -301,7 +301,8 @@ static void handle_arg_cannoli(const char *arg)
     }
 
     /* Get the entry point for Cannoli */
-    Cannoli* (*query_version)(void) = dlsym(cannoli_lib, CANNOLI_ENTRY);
+    Cannoli* (*query_version)(const char*, int) =
+        dlsym(cannoli_lib, CANNOLI_ENTRY);
     if(!query_version) {
         fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
             dlerror());
@@ -309,7 +310,7 @@ static void handle_arg_cannoli(const char *arg)
     }
 
     /* Query binding information */
-    cannoli = query_version();
+    cannoli = query_version(UNAME_MACHINE, TARGET_BIG_ENDIAN != 0);
 
     /* Check version */
     if(cannoli->version != CANNOLI_VERSION) {
-- 
2.39.1


From e40ad6157c92f56e1887d1925e9a0fe15104991a Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Wed, 13 Jul 2022 13:58:58 -0700
Subject: [PATCH 10/14] Added loongarch support

---
 target/loongarch/cpu.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/target/loongarch/cpu.h b/target/loongarch/cpu.h
index e35cf65597..c7c737ee0a 100644
--- a/target/loongarch/cpu.h
+++ b/target/loongarch/cpu.h
@@ -327,6 +327,13 @@ typedef struct CPUArchState {
     bool load_elf;
     uint64_t elf_address;
 #endif
+
+#ifdef CONFIG_CANNOLI
+    /* Storage for Cannoli's internal register state */
+    uint64_t cannoli_r12;
+    uint64_t cannoli_r13;
+    uint64_t cannoli_r14;
+#endif
 } CPULoongArchState;
 
 /**
-- 
2.39.1


From 572ded946755458e2268d64ad69ce07f8bcbec7c Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Wed, 13 Jul 2022 19:03:29 -0700
Subject: [PATCH 11/14] Added mmap hooks

---
 include/tcg/tcg.h |  2 +-
 linux-user/mmap.c | 35 +++++++++++++++++++++++++++++++++++
 2 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/include/tcg/tcg.h b/include/tcg/tcg.h
index addad049af..e99c43a80a 100644
--- a/include/tcg/tcg.h
+++ b/include/tcg/tcg.h
@@ -44,7 +44,7 @@
 #ifdef CONFIG_CANNOLI
 #define CANNOLI
 #ifdef CANNOLI
-#include "cannoli_server/ffi/cannoli.h"
+#include "jitter/ffi/cannoli.h"
 
 /*
  * Defined in `linux-user/main.c`. Holds global cannoli state and callback
diff --git a/linux-user/mmap.c b/linux-user/mmap.c
index 10f5079331..c60adc3c63 100644
--- a/linux-user/mmap.c
+++ b/linux-user/mmap.c
@@ -24,6 +24,11 @@
 #include "user-mmap.h"
 #include "target_mman.h"
 
+#ifdef CONFIG_CANNOLI
+/* Pull in TCG header that has cannoli */
+#include "tcg/tcg.h"
+#endif
+
 static pthread_mutex_t mmap_mutex = PTHREAD_MUTEX_INITIALIZER;
 static __thread int mmap_lock_count;
 
@@ -652,6 +657,29 @@ abi_long target_mmap(abi_ulong start, abi_ulong len, int target_prot,
         }
     }
  the_end:
+#ifdef CONFIG_CANNOLI
+    if(cannoli && cannoli->mmap) {
+        /* Report when mmap() occurs successfully */
+
+        /* Resolve the path for this FD if this is a non-anon mapping */
+        char *pth = NULL;
+        if(!(flags & MAP_ANONYMOUS)) {
+            char buf[64];
+            sprintf(buf, "/proc/%d/fd/%d", getpid(), fd);
+            pth = realpath(buf, NULL);
+        }
+
+        cannoli->mmap(start, len, (flags & MAP_ANONYMOUS) != 0,
+            (target_prot & PROT_READ) != 0, (target_prot & PROT_WRITE) != 0,
+            (target_prot & PROT_EXEC) != 0, pth, offset);
+
+        /* Free the path */
+        if(pth) {
+            free(pth);
+        }
+    }
+#endif
+
     trace_target_mmap_complete(start);
     if (qemu_loglevel_mask(CPU_LOG_PAGE)) {
         FILE *f = qemu_log_trylock();
@@ -716,6 +744,13 @@ int target_munmap(abi_ulong start, abi_ulong len)
 
     trace_target_munmap(start, len);
 
+#ifdef CONFIG_CANNOLI
+    if(cannoli && cannoli->munmap) {
+        /* Report when we try to unmap memory */
+        cannoli->munmap(start, len);
+    }
+#endif
+
     if (start & ~TARGET_PAGE_MASK)
         return -TARGET_EINVAL;
     len = TARGET_PAGE_ALIGN(len);
-- 
2.39.1


From 4f909fa37c96237f4405a3c42bbbc2d813a6bd45 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Fri, 29 Jul 2022 18:11:59 -0700
Subject: [PATCH 12/14] Add register patches

---
 linux-user/main.c | 95 ++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 93 insertions(+), 2 deletions(-)

diff --git a/linux-user/main.c b/linux-user/main.c
index 060a09b3f8..7d4e67f66b 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -301,7 +301,7 @@ static void handle_arg_cannoli(const char *arg)
     }
 
     /* Get the entry point for Cannoli */
-    Cannoli* (*query_version)(const char*, int) =
+    Cannoli* (*query_version)(const char*, int, size_t, size_t, size_t) =
         dlsym(cannoli_lib, CANNOLI_ENTRY);
     if(!query_version) {
         fprintf(stderr, "Cannoli: Failed to get entry point \"%s\"\n",
@@ -309,8 +309,99 @@ static void handle_arg_cannoli(const char *arg)
         exit(EXIT_FAILURE);
     }
 
+    /* Determine the offset to GPRs and size of GPRs for this architecture in
+     * the `CPUArchState` structure (pointed to in the JIT by RBP)
+     */
+    size_t gpr_offset;
+    size_t gpr_width;
+    size_t num_gprs;
+
+    /* Create an arch state so we can get some offsets and sizes from it */
+    CPUArchState as;
+
+#ifdef TARGET_ALPHA
+    gpr_offset = offsetof(CPUArchState, ir);
+    gpr_width  = sizeof(as.ir[0]);
+    num_gprs   = sizeof(as.ir) / gpr_width;
+#endif /* TARGET_ALPHA */
+
+#ifdef TARGET_AARCH64
+    /* Idk if this is right, they might use the 32-bit regs in 32-bit mode when
+     * running on aarch64? Not sure. I don't think many Linux-user targets will
+     * use mixed modes anyways so we're probably fine
+     */
+    gpr_offset = offsetof(CPUArchState, xregs);
+    gpr_width  = sizeof(as.xregs[0]);
+    num_gprs   = sizeof(as.xregs) / gpr_width;
+#elif defined(TARGET_ARM)
+    gpr_offset = offsetof(CPUArchState, regs);
+    gpr_width  = sizeof(as.regs[0]);
+    num_gprs   = sizeof(as.regs) / gpr_width;
+#endif /* TARGET_AARCH64 */
+
+#ifdef TARGET_AVR
+    gpr_offset = offsetof(CPUArchState, r);
+    gpr_width  = sizeof(as.r[0]);
+    num_gprs   = sizeof(as.r) / gpr_width;
+#endif /* TARGET_AVR */
+
+#ifdef TARGET_HPPA
+    gpr_offset = offsetof(CPUArchState, gr);
+    gpr_width  = sizeof(as.gr[0]);
+    num_gprs   = sizeof(as.gr) / gpr_width;
+#endif /* TARGET_HPPA */
+
+#ifdef TARGET_M68K
+    gpr_offset = offsetof(CPUArchState, dregs);
+    gpr_width  = sizeof(as.dregs[0]);
+    num_gprs   = (sizeof(as.dregs) + sizeof(as.aregs)) / gpr_width;
+#endif /* TARGET_M68K */
+
+#ifdef TARGET_MIPS
+    gpr_offset = offsetof(CPUArchState, active_tc.gpr);
+    gpr_width  = sizeof(as.active_tc.gpr[0]);
+    num_gprs   = sizeof(as.active_tc.gpr) / gpr_width;
+#endif /* TARGET_MIPS */
+
+#ifdef TARGET_TRICORE
+    gpr_offset = offsetof(CPUArchState, gpr_a);
+    gpr_width  = sizeof(as.gpr_a[0]);
+    num_gprs   = (sizeof(as.gpr_a) + sizeof(as.gpr_d)) / gpr_width;
+#endif /* TARGET_TRICORE */
+
+#ifdef TARGET_OPENRISC
+    gpr_offset = offsetof(CPUArchState, shadow_gpr);
+    gpr_width  = sizeof(as.shadow_gpr[0]);
+    num_gprs   = sizeof(as.shadow_gpr) / gpr_width;
+#endif /* TARGET_OPENRISC */
+
+    /* All architectures that just use `CPUArchState->gregs` */
+#if defined(TARGET_SH4) || defined(TARGET_SPARC)
+    gpr_offset = offsetof(CPUArchState, gregs);
+    gpr_width  = sizeof(as.gregs[0]);
+    num_gprs   = sizeof(as.gregs) / gpr_width;
+#endif
+
+    /* All architectures that just use `CPUArchState->regs` */
+#if defined(TARGET_CRIS) || defined(TARGET_I386) || \
+        defined(TARGET_MICROBLAZE) || defined(TARGET_NIOS2) || \
+        defined(TARGET_RX) || defined(TARGET_S390X) || defined(TARGET_XTENSA)
+    gpr_offset = offsetof(CPUArchState, regs);
+    gpr_width  = sizeof(as.regs[0]);
+    num_gprs   = sizeof(as.regs) / gpr_width;
+#endif
+
+    /* All architectures that just use `CPUArchState->gpr` */
+#if defined(TARGET_HEXAGON) || defined(TARGET_LOONGARCH) || \
+        defined(TARGET_PPC) || defined(TARGET_RISCV)
+    gpr_offset = offsetof(CPUArchState, gpr);
+    gpr_width  = sizeof(as.gpr[0]);
+    num_gprs   = sizeof(as.gpr) / gpr_width;
+#endif /* TARGET_HEXAGON */
+
     /* Query binding information */
-    cannoli = query_version(UNAME_MACHINE, TARGET_BIG_ENDIAN != 0);
+    cannoli = query_version(UNAME_MACHINE, TARGET_BIG_ENDIAN != 0,
+        gpr_offset, gpr_width, num_gprs);
 
     /* Check version */
     if(cannoli->version != CANNOLI_VERSION) {
-- 
2.39.1


From 05913bff4e6f5f042f474be492985a0079c22a7e Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Sun, 7 Aug 2022 10:32:01 -0700
Subject: [PATCH 13/14] Added branch support for cannoli

---
 tcg/tcg.c | 30 +++++++++++++++++++++++++++++-
 1 file changed, 29 insertions(+), 1 deletion(-)

diff --git a/tcg/tcg.c b/tcg/tcg.c
index 9e8b22beb6..4021981e36 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -4786,13 +4786,41 @@ int tcg_gen_code(TCGContext *s, TranslationBlock *tb, target_ulong pc_start)
              * access the `gen_insn_data` ourselves
              */
             if(cannoli && cannoli->lift_instruction) {
+                /* Look ahead at the TCG instructions for this instruction. If
+                 * there is one that is a basic block end, we save that info
+                 * off. Here we're just looking for what could be branches.
+                 * All branches are basic block ends in TCG, some other things
+                 * are also BB ends, but that's okay, we won't have
+                 * false-negatives, only false-positives.
+                 */
+                TCGOp *tmp_op = op->link.tqe_next;
+                int bb_end_in_inst = 0;
+                while(tmp_op) {
+                    if(tmp_op->opc == INDEX_op_insn_start) {
+                        /* Stop processing when we get to the next instruction
+                         * start.
+                         */
+                        break;
+                    }
+
+                    /* Check if this instruction ends a basic block */
+                    TCGOpDef *def = &tcg_op_defs[tmp_op->opc];
+                    if(def->flags & TCG_OPF_BB_END) {
+                        bb_end_in_inst = 1;
+                    }
+
+                    /* Go to the next op */
+                    tmp_op = tmp_op->link.tqe_next;
+                }
+
                 /* Should be large enough for any reasonable shellcode */
                 uint8_t shellcode[1024];
 
                 /* Invoke lifting callback */
                 size_t shellcode_size =
                     cannoli->lift_instruction(
-                        cannoli_pc, shellcode, sizeof(shellcode));
+                        cannoli_pc, bb_end_in_inst,
+                        shellcode, sizeof(shellcode));
 
                 /* Make sure the SO library author is not being naughty ;) */
                 if(shellcode_size > sizeof(shellcode)) {
-- 
2.39.1


From 7b76bcdf4646147af6b1d2e8db6e29ab752e8f91 Mon Sep 17 00:00:00 2001
From: Brandon Falk <bfalk@gamozolabs.com>
Date: Mon, 23 Jan 2023 13:28:55 -0800
Subject: [PATCH 14/14] Updated to latest QEMU
 00b1faea41d283e931256aa78aa975a369ec3ae6

---
 tcg/i386/tcg-target.c.inc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/tcg/i386/tcg-target.c.inc b/tcg/i386/tcg-target.c.inc
index 030f1557e4..87b5c8f097 100644
--- a/tcg/i386/tcg-target.c.inc
+++ b/tcg/i386/tcg-target.c.inc
@@ -4234,7 +4234,7 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDI, TCG_REG_RSP);
 
         /* Invoke the JIT entry callback */
-        tcg_out_call(s, (void*)cannoli->jit_entry);
+        tcg_out_call(s, (void*)cannoli->jit_entry, NULL);
 
         /*
          * Load the temporary values returned from `jit_entry`. These are the
@@ -4341,7 +4341,7 @@ static void tcg_target_qemu_prologue(TCGContext *s)
         tcg_out_mov(s, TCG_TYPE_PTR, TCG_REG_RDX, TCG_REG_R14);
 
         /* Invoke the callback! */
-        tcg_out_call(s, (void*)cannoli->jit_exit);
+        tcg_out_call(s, (void*)cannoli->jit_exit, NULL);
 
         /* Restore the stack */
         tcg_out_pop(s, TCG_REG_R11);
-- 
2.39.1

